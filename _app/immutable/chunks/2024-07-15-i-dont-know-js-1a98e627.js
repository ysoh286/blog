import{S as Ls,i as Ws,s as qs,e as s,t as o,a as f,c as i,b as n,d as a,f as t,g as d,k as v,h as c,j as l,n as ca}from"./index-794e8e40.js";function Ns(Es){let T,$t,at,F,zt,st,Z,Xt,it,$,Qt,nt,z,Vt,rt,m,el,be,tl,ll,_e,ol,al,Oe,sl,il,xe,nl,rl,ct,X,cl,ft,W,bs=`<code class="language-undefined">&#39;1&#39; == 1 // true
&#39;1&#39; === 1 // false</code>`,dt,Q,fl,ut,h,dl,De,ul,pl,Ce,hl,vl,Te,ml,yl,Ie,wl,El,Se,bl,_l,q,Ol,xl,pt,I,Dl,ke,Cl,Tl,ht,_,w,Il,Pe,Sl,kl,Ae,Pl,Al,He,Hl,Jl,Ll,E,Wl,Je,ql,Nl,Le,gl,Bl,We,Kl,Rl,Ml,b,jl,qe,Ul,Gl,Ne,Yl,Fl,ge,Zl,$l,vt,S,zl,Be,Xl,Ql,mt,O,Vl,Ke,eo,to,Re,lo,oo,yt,N,_s=`<code class="language-undefined">const a = [&#39;ABC&#39;];

a[1] = &#39;XYZ&#39;;

console.log(a); // [&#39;ABC&#39;, &#39;XYZ&#39;]</code>`,wt,V,ao,Et,ee,so,bt,te,C,io,Me,no,ro,je,co,fo,_t,k,uo,Ue,po,ho,Ot,P,vo,Ge,mo,yo,xt,g,Os=`<code class="language-undefined">const a = &#39;hello&#39;;

a = &#39;goodbye&#39;;
// throws TypeError (assignment to constant variable)</code>`,Dt,A,wo,Ye,Eo,bo,Ct,B,xs=`<code class="language-undefined">// function declaration
function sayHello(name) &#123;
    console.log(&#96;Hello $&#123;name&#125;!&#96;);
&#125;


// function expression
var sayHello = function() &#123;
    console.log(&#96;Hello $&#123;name&#125;!&#96;);
&#125;</code>`,Tt,le,_o,It,oe,Oo,St,ae,xo,kt,se,Do,Pt,ie,Fe,Co,At,K,Ds=`<code class="language-undefined">function multiply() =&gt; &#123;
    let value = 10;

    // inner function has access to outer variable
    // and preserves it
    function multiplyBy2() &#123;
        return value * 2;
    &#125;
    multiplyBy2();
&#125;

multiply();</code>`,Ht,ne,To,Jt,re,Io,Lt,ce,Ze,So,Wt,fe,ko,qt,R,Cs=`<code class="language-undefined">sayHello();

function sayHello(name) &#123;
    console.log(&#96;Hello $&#123;name&#125;&#96;);
&#125;</code>`,Nt,de,Po,gt,M,Ts=`<code class="language-undefined">a = &#39;hmm&#39;;

var a;</code>`,Bt,u,Ao,$e,Ho,Jo,ze,Lo,Wo,Xe,qo,No,Qe,go,Bo,Ve,Ko,Ro,et,Mo,jo,tt,Uo,Go,lt,Yo,Fo,ot,Zo,$o,Kt,ue,zo,Rt,pe,Xo,Mt,x,j,Qo,U,Vo,ea,ta,he,la,G,oa,aa,ve,Y,sa,ia;return{c(){T=s("p"),$t=o(`It’s been 5+ years since I’ve been a front-end engineer.
As one, you’re generally expected to know JavaScript, the main programming language for the web.`),at=f(),F=s("p"),zt=o("I thought I knew some, until I didn’t. Pretty bad, huh?"),st=f(),Z=s("p"),Xt=o("I don’t know JS. Kyle Simpson’s books says it all: “YOU DON’T KNOW JS!” and we certainly don’t."),it=f(),$=s("p"),Qt=o("5 things I’ve learned recently:"),nt=f(),z=s("h3"),Vt=o("1. The real difference between == and ==="),rt=f(),m=s("p"),el=o("The "),be=s("code"),tl=o("=="),ll=o(" (abstract equality operator) and "),_e=s("code"),ol=o("==="),al=o(` (strict equality operator) are generally used for comparisons.
We often get told `),Oe=s("code"),sl=o("=="),il=o(" only compares values while "),xe=s("code"),nl=o("==="),rl=o(" compares both types and values."),ct=f(),X=s("p"),cl=o("e.g."),ft=f(),W=s("pre"),dt=f(),Q=s("p"),fl=o("Though, that’s only half true."),ut=f(),h=s("p"),dl=o(`The actual answer:
`),De=s("code"),ul=o("=="),pl=o(" does actually compare types, but it does type coercion if the types are different before comparing values, while "),Ce=s("code"),hl=o("==="),vl=o(" does not. "),Te=s("code"),ml=o("==="),yl=o(` does compare both types and values, but essentially if the types are NOT equal, then it will automatically return false.
`),Ie=s("code"),wl=o("=="),El=o(" on the other hand will actually do exactly what "),Se=s("code"),bl=o("==="),_l=o(" does if the types are equal. If the types are NOT equal, then it will try to do type coercion before comparing values. Refer to the "),q=s("a"),Ol=o("ECMAScript"),xl=o(" spec for more details."),pt=f(),I=s("p"),Dl=o("In summary, "),ke=s("code"),Cl=o("=="),Tl=o(" will try to type coerce in the following order:"),ht=f(),_=s("ul"),w=s("li"),Il=o("If "),Pe=s("code"),Sl=o("A"),kl=o(" is a primitive type, and "),Ae=s("code"),Pl=o("B"),Al=o(" is not, it will try convert "),He=s("code"),Hl=o("B"),Jl=o(" into a primitive type for comparison."),Ll=f(),E=s("li"),Wl=o("Generally, if "),Je=s("code"),ql=o("A"),Nl=o(" is a string / boolean (or some other primitive) and "),Le=s("code"),gl=o("B"),Bl=o(" is a number, then it will always try to convert "),We=s("code"),Kl=o("A"),Rl=o(" to a number."),Ml=f(),b=s("li"),jl=o("Note that empty string "),qe=s("code"),Ul=o('""'),Gl=o(" gets converted to "),Ne=s("code"),Yl=o("0"),Fl=o(" which usually explains the (presumably ‘weird’, but actually is by design) behaviour that occurs when you compare different things in JavaScript with "),ge=s("code"),Zl=o("=="),$l=o("."),vt=f(),S=s("h3"),zl=o("2. "),Be=s("code"),Xl=o("const"),Ql=o(" doesn’t actually mean “constant” by english terms, but by programmatic terms which are NOT the same"),mt=f(),O=s("p"),Vl=o("Ever wondered why "),Ke=s("code"),eo=o("const"),to=o(" was called "),Re=s("code"),lo=o("const"),oo=o(" when we can do something like this:"),yt=f(),N=s("pre"),wt=f(),V=s("p"),ao=o("Wait what? Isn’t it supposed to be constant though? Why did it change?"),Et=f(),ee=s("p"),so=o("Actual answer:"),bt=f(),te=s("ul"),C=s("li"),io=o("What "),Me=s("code"),no=o("const"),ro=o(` (constant) means in programming terms differs from what it means in english.
In english, we expect `),je=s("code"),co=o("constant"),fo=o(" to mean fixed, immutable, cannot be changed whatsoever."),_t=f(),k=s("p"),uo=o("But in programming terms, it means "),Ue=s("strong"),po=o("a variable that CANNOT be re-assigned"),ho=o("."),Ot=f(),P=s("p"),vo=o("This explains this behaviour where we cannot reassign "),Ge=s("code"),mo=o("const"),yo=o(" variables, however you can still mutate them like above."),xt=f(),g=s("pre"),Dt=f(),A=s("h3"),wo=o("3. The difference between a function declaration and a function expression, is declaring "),Ye=s("code"),Eo=o("function"),bo=o(" being at the start and its enclosing scope"),Ct=f(),B=s("pre"),Tt=f(),le=s("p"),_o=o("Above, the function expression has defined its own function scope, while the function declaration has access to its enclosed scope and has its name attached."),It=f(),oe=s("h3"),Oo=o("4. Closures aren’t about just storing data or values, it’s about lexical scope"),St=f(),ae=s("p"),xo=o("Generally, when we get asked about closure, we tend to explain it through being able to access data that’s not in the same scope or storing values."),kt=f(),se=s("p"),Do=o("Actual answer:"),Pt=f(),ie=s("blockquote"),Fe=s("p"),Co=o("When a function ‘remembers’ its lexical scope even when the function is executed OUTSIDE of that lexical scope."),At=f(),K=s("pre"),Ht=f(),ne=s("h3"),To=o("5. Hoisting is just a name for describing some ‘complex’ behaviour in JavaScript, but is all tied to lexical scoping and how it works at compile and execution time."),Jt=f(),re=s("p"),Io=o("What hoisting is sometimes described as:"),Lt=f(),ce=s("ul"),Ze=s("li"),So=o(`moving variable and function declarations at the ‘top’
…even though that’s not actually what happens.`),Wt=f(),fe=s("p"),ko=o("Actual answer: JavaScript gets compiled, then executed. During the compilation phase, scopes are created (global, function, block) for variable declarations. However, values are assigned during execution phase. This explains why sometimes when you write functions before you actually call them, JS has no problem executing, as the function scopes are already defined before execution."),qt=f(),R=s("pre"),Nt=f(),de=s("p"),Po=o("Similarly, you can do this with variables as well, but it’s usually bad to (and generally not a good idea)."),gt=f(),M=s("pre"),Bt=f(),u=s("p"),Ao=o("What about "),$e=s("code"),Ho=o("const"),Jo=o(" and "),ze=s("code"),Lo=o("let"),Wo=o(" ? These do get ‘hoisted’ but because they are uninitialised, it leads to the need of the "),Xe=s("code"),qo=o("TDZ"),No=o(" = known as the temporal dead zone, which is needed as "),Qe=s("code"),go=o("const"),Bo=o(" cannot be initialised as ‘undefined’ only to be reassigned later (as this would break the definition of "),Ve=s("code"),Ko=o("const"),Ro=o(" in programming terms). Generally when we define "),et=s("code"),Mo=o("var"),jo=o(", its initial value is "),tt=s("code"),Uo=o("undefined"),Go=o(`.
We rarely get this error as we are strongly advised to always declare `),lt=s("code"),Yo=o("const"),Fo=o(" and "),ot=s("code"),Zo=o("let"),$o=o(" with actual assignments anyway."),Kt=f(),ue=s("p"),zo=o("There’s definitely more to come as I continue to keep learning!"),Rt=f(),pe=s("p"),Xo=o("References / credits to:"),Mt=f(),x=s("ul"),j=s("li"),Qo=o("Kyle Simpson’s "),U=s("a"),Vo=o("Deep JavaScript Foundations"),ea=o(" course on FrontEnd Masters"),ta=f(),he=s("li"),la=o("Kyle Simpson’s "),G=s("a"),oa=o("“You Don’t Know JS”"),aa=f(),ve=s("li"),Y=s("a"),sa=o("JavaScript questions"),ia=o(" in the Front End Interview Handbook"),this.h()},l(e){T=i(e,"P",{});var r=n(T);$t=a(r,`It’s been 5+ years since I’ve been a front-end engineer.
As one, you’re generally expected to know JavaScript, the main programming language for the web.`),r.forEach(t),at=d(e),F=i(e,"P",{});var fa=n(F);zt=a(fa,"I thought I knew some, until I didn’t. Pretty bad, huh?"),fa.forEach(t),st=d(e),Z=i(e,"P",{});var da=n(Z);Xt=a(da,"I don’t know JS. Kyle Simpson’s books says it all: “YOU DON’T KNOW JS!” and we certainly don’t."),da.forEach(t),it=d(e),$=i(e,"P",{});var ua=n($);Qt=a(ua,"5 things I’ve learned recently:"),ua.forEach(t),nt=d(e),z=i(e,"H3",{});var pa=n(z);Vt=a(pa,"1. The real difference between == and ==="),pa.forEach(t),rt=d(e),m=i(e,"P",{});var D=n(m);el=a(D,"The "),be=i(D,"CODE",{});var ha=n(be);tl=a(ha,"=="),ha.forEach(t),ll=a(D," (abstract equality operator) and "),_e=i(D,"CODE",{});var va=n(_e);ol=a(va,"==="),va.forEach(t),al=a(D,` (strict equality operator) are generally used for comparisons.
We often get told `),Oe=i(D,"CODE",{});var ma=n(Oe);sl=a(ma,"=="),ma.forEach(t),il=a(D," only compares values while "),xe=i(D,"CODE",{});var ya=n(xe);nl=a(ya,"==="),ya.forEach(t),rl=a(D," compares both types and values."),D.forEach(t),ct=d(e),X=i(e,"P",{});var wa=n(X);cl=a(wa,"e.g."),wa.forEach(t),ft=d(e),W=i(e,"PRE",{class:!0});var Is=n(W);Is.forEach(t),dt=d(e),Q=i(e,"P",{});var Ea=n(Q);fl=a(Ea,"Though, that’s only half true."),Ea.forEach(t),ut=d(e),h=i(e,"P",{});var y=n(h);dl=a(y,`The actual answer:
`),De=i(y,"CODE",{});var ba=n(De);ul=a(ba,"=="),ba.forEach(t),pl=a(y," does actually compare types, but it does type coercion if the types are different before comparing values, while "),Ce=i(y,"CODE",{});var _a=n(Ce);hl=a(_a,"==="),_a.forEach(t),vl=a(y," does not. "),Te=i(y,"CODE",{});var Oa=n(Te);ml=a(Oa,"==="),Oa.forEach(t),yl=a(y,` does compare both types and values, but essentially if the types are NOT equal, then it will automatically return false.
`),Ie=i(y,"CODE",{});var xa=n(Ie);wl=a(xa,"=="),xa.forEach(t),El=a(y," on the other hand will actually do exactly what "),Se=i(y,"CODE",{});var Da=n(Se);bl=a(Da,"==="),Da.forEach(t),_l=a(y," does if the types are equal. If the types are NOT equal, then it will try to do type coercion before comparing values. Refer to the "),q=i(y,"A",{href:!0,rel:!0});var Ca=n(q);Ol=a(Ca,"ECMAScript"),Ca.forEach(t),xl=a(y," spec for more details."),y.forEach(t),pt=d(e),I=i(e,"P",{});var jt=n(I);Dl=a(jt,"In summary, "),ke=i(jt,"CODE",{});var Ta=n(ke);Cl=a(Ta,"=="),Ta.forEach(t),Tl=a(jt," will try to type coerce in the following order:"),jt.forEach(t),ht=d(e),_=i(e,"UL",{});var me=n(_);w=i(me,"LI",{});var H=n(w);Il=a(H,"If "),Pe=i(H,"CODE",{});var Ia=n(Pe);Sl=a(Ia,"A"),Ia.forEach(t),kl=a(H," is a primitive type, and "),Ae=i(H,"CODE",{});var Sa=n(Ae);Pl=a(Sa,"B"),Sa.forEach(t),Al=a(H," is not, it will try convert "),He=i(H,"CODE",{});var ka=n(He);Hl=a(ka,"B"),ka.forEach(t),Jl=a(H," into a primitive type for comparison."),H.forEach(t),Ll=d(me),E=i(me,"LI",{});var J=n(E);Wl=a(J,"Generally, if "),Je=i(J,"CODE",{});var Pa=n(Je);ql=a(Pa,"A"),Pa.forEach(t),Nl=a(J," is a string / boolean (or some other primitive) and "),Le=i(J,"CODE",{});var Aa=n(Le);gl=a(Aa,"B"),Aa.forEach(t),Bl=a(J," is a number, then it will always try to convert "),We=i(J,"CODE",{});var Ha=n(We);Kl=a(Ha,"A"),Ha.forEach(t),Rl=a(J," to a number."),J.forEach(t),Ml=d(me),b=i(me,"LI",{});var L=n(b);jl=a(L,"Note that empty string "),qe=i(L,"CODE",{});var Ja=n(qe);Ul=a(Ja,'""'),Ja.forEach(t),Gl=a(L," gets converted to "),Ne=i(L,"CODE",{});var La=n(Ne);Yl=a(La,"0"),La.forEach(t),Fl=a(L," which usually explains the (presumably ‘weird’, but actually is by design) behaviour that occurs when you compare different things in JavaScript with "),ge=i(L,"CODE",{});var Wa=n(ge);Zl=a(Wa,"=="),Wa.forEach(t),$l=a(L,"."),L.forEach(t),me.forEach(t),vt=d(e),S=i(e,"H3",{});var Ut=n(S);zl=a(Ut,"2. "),Be=i(Ut,"CODE",{});var qa=n(Be);Xl=a(qa,"const"),qa.forEach(t),Ql=a(Ut," doesn’t actually mean “constant” by english terms, but by programmatic terms which are NOT the same"),Ut.forEach(t),mt=d(e),O=i(e,"P",{});var ye=n(O);Vl=a(ye,"Ever wondered why "),Ke=i(ye,"CODE",{});var Na=n(Ke);eo=a(Na,"const"),Na.forEach(t),to=a(ye," was called "),Re=i(ye,"CODE",{});var ga=n(Re);lo=a(ga,"const"),ga.forEach(t),oo=a(ye," when we can do something like this:"),ye.forEach(t),yt=d(e),N=i(e,"PRE",{class:!0});var Ss=n(N);Ss.forEach(t),wt=d(e),V=i(e,"P",{});var Ba=n(V);ao=a(Ba,"Wait what? Isn’t it supposed to be constant though? Why did it change?"),Ba.forEach(t),Et=d(e),ee=i(e,"P",{});var Ka=n(ee);so=a(Ka,"Actual answer:"),Ka.forEach(t),bt=d(e),te=i(e,"UL",{});var Ra=n(te);C=i(Ra,"LI",{});var we=n(C);io=a(we,"What "),Me=i(we,"CODE",{});var Ma=n(Me);no=a(Ma,"const"),Ma.forEach(t),ro=a(we,` (constant) means in programming terms differs from what it means in english.
In english, we expect `),je=i(we,"CODE",{});var ja=n(je);co=a(ja,"constant"),ja.forEach(t),fo=a(we," to mean fixed, immutable, cannot be changed whatsoever."),we.forEach(t),Ra.forEach(t),_t=d(e),k=i(e,"P",{});var Gt=n(k);uo=a(Gt,"But in programming terms, it means "),Ue=i(Gt,"STRONG",{});var Ua=n(Ue);po=a(Ua,"a variable that CANNOT be re-assigned"),Ua.forEach(t),ho=a(Gt,"."),Gt.forEach(t),Ot=d(e),P=i(e,"P",{});var Yt=n(P);vo=a(Yt,"This explains this behaviour where we cannot reassign "),Ge=i(Yt,"CODE",{});var Ga=n(Ge);mo=a(Ga,"const"),Ga.forEach(t),yo=a(Yt," variables, however you can still mutate them like above."),Yt.forEach(t),xt=d(e),g=i(e,"PRE",{class:!0});var ks=n(g);ks.forEach(t),Dt=d(e),A=i(e,"H3",{});var Ft=n(A);wo=a(Ft,"3. The difference between a function declaration and a function expression, is declaring "),Ye=i(Ft,"CODE",{});var Ya=n(Ye);Eo=a(Ya,"function"),Ya.forEach(t),bo=a(Ft," being at the start and its enclosing scope"),Ft.forEach(t),Ct=d(e),B=i(e,"PRE",{class:!0});var Ps=n(B);Ps.forEach(t),Tt=d(e),le=i(e,"P",{});var Fa=n(le);_o=a(Fa,"Above, the function expression has defined its own function scope, while the function declaration has access to its enclosed scope and has its name attached."),Fa.forEach(t),It=d(e),oe=i(e,"H3",{});var Za=n(oe);Oo=a(Za,"4. Closures aren’t about just storing data or values, it’s about lexical scope"),Za.forEach(t),St=d(e),ae=i(e,"P",{});var $a=n(ae);xo=a($a,"Generally, when we get asked about closure, we tend to explain it through being able to access data that’s not in the same scope or storing values."),$a.forEach(t),kt=d(e),se=i(e,"P",{});var za=n(se);Do=a(za,"Actual answer:"),za.forEach(t),Pt=d(e),ie=i(e,"BLOCKQUOTE",{});var Xa=n(ie);Fe=i(Xa,"P",{});var Qa=n(Fe);Co=a(Qa,"When a function ‘remembers’ its lexical scope even when the function is executed OUTSIDE of that lexical scope."),Qa.forEach(t),Xa.forEach(t),At=d(e),K=i(e,"PRE",{class:!0});var As=n(K);As.forEach(t),Ht=d(e),ne=i(e,"H3",{});var Va=n(ne);To=a(Va,"5. Hoisting is just a name for describing some ‘complex’ behaviour in JavaScript, but is all tied to lexical scoping and how it works at compile and execution time."),Va.forEach(t),Jt=d(e),re=i(e,"P",{});var es=n(re);Io=a(es,"What hoisting is sometimes described as:"),es.forEach(t),Lt=d(e),ce=i(e,"UL",{});var ts=n(ce);Ze=i(ts,"LI",{});var ls=n(Ze);So=a(ls,`moving variable and function declarations at the ‘top’
…even though that’s not actually what happens.`),ls.forEach(t),ts.forEach(t),Wt=d(e),fe=i(e,"P",{});var os=n(fe);ko=a(os,"Actual answer: JavaScript gets compiled, then executed. During the compilation phase, scopes are created (global, function, block) for variable declarations. However, values are assigned during execution phase. This explains why sometimes when you write functions before you actually call them, JS has no problem executing, as the function scopes are already defined before execution."),os.forEach(t),qt=d(e),R=i(e,"PRE",{class:!0});var Hs=n(R);Hs.forEach(t),Nt=d(e),de=i(e,"P",{});var as=n(de);Po=a(as,"Similarly, you can do this with variables as well, but it’s usually bad to (and generally not a good idea)."),as.forEach(t),gt=d(e),M=i(e,"PRE",{class:!0});var Js=n(M);Js.forEach(t),Bt=d(e),u=i(e,"P",{});var p=n(u);Ao=a(p,"What about "),$e=i(p,"CODE",{});var ss=n($e);Ho=a(ss,"const"),ss.forEach(t),Jo=a(p," and "),ze=i(p,"CODE",{});var is=n(ze);Lo=a(is,"let"),is.forEach(t),Wo=a(p," ? These do get ‘hoisted’ but because they are uninitialised, it leads to the need of the "),Xe=i(p,"CODE",{});var ns=n(Xe);qo=a(ns,"TDZ"),ns.forEach(t),No=a(p," = known as the temporal dead zone, which is needed as "),Qe=i(p,"CODE",{});var rs=n(Qe);go=a(rs,"const"),rs.forEach(t),Bo=a(p," cannot be initialised as ‘undefined’ only to be reassigned later (as this would break the definition of "),Ve=i(p,"CODE",{});var cs=n(Ve);Ko=a(cs,"const"),cs.forEach(t),Ro=a(p," in programming terms). Generally when we define "),et=i(p,"CODE",{});var fs=n(et);Mo=a(fs,"var"),fs.forEach(t),jo=a(p,", its initial value is "),tt=i(p,"CODE",{});var ds=n(tt);Uo=a(ds,"undefined"),ds.forEach(t),Go=a(p,`.
We rarely get this error as we are strongly advised to always declare `),lt=i(p,"CODE",{});var us=n(lt);Yo=a(us,"const"),us.forEach(t),Fo=a(p," and "),ot=i(p,"CODE",{});var ps=n(ot);Zo=a(ps,"let"),ps.forEach(t),$o=a(p," with actual assignments anyway."),p.forEach(t),Kt=d(e),ue=i(e,"P",{});var hs=n(ue);zo=a(hs,"There’s definitely more to come as I continue to keep learning!"),hs.forEach(t),Rt=d(e),pe=i(e,"P",{});var vs=n(pe);Xo=a(vs,"References / credits to:"),vs.forEach(t),Mt=d(e),x=i(e,"UL",{});var Ee=n(x);j=i(Ee,"LI",{});var Zt=n(j);Qo=a(Zt,"Kyle Simpson’s "),U=i(Zt,"A",{href:!0,rel:!0});var ms=n(U);Vo=a(ms,"Deep JavaScript Foundations"),ms.forEach(t),ea=a(Zt," course on FrontEnd Masters"),Zt.forEach(t),ta=d(Ee),he=i(Ee,"LI",{});var na=n(he);la=a(na,"Kyle Simpson’s "),G=i(na,"A",{href:!0,rel:!0});var ys=n(G);oa=a(ys,"“You Don’t Know JS”"),ys.forEach(t),na.forEach(t),aa=d(Ee),ve=i(Ee,"LI",{});var ra=n(ve);Y=i(ra,"A",{href:!0,rel:!0});var ws=n(Y);sa=a(ws,"JavaScript questions"),ws.forEach(t),ia=a(ra," in the Front End Interview Handbook"),ra.forEach(t),Ee.forEach(t),this.h()},h(){v(W,"class","language-undefined"),v(q,"href","https://262.ecma-international.org/5.1/#sec-11.9.3"),v(q,"rel","nofollow"),v(N,"class","language-undefined"),v(g,"class","language-undefined"),v(B,"class","language-undefined"),v(K,"class","language-undefined"),v(R,"class","language-undefined"),v(M,"class","language-undefined"),v(U,"href","https://frontendmasters.com/courses/deep-javascript-v3/"),v(U,"rel","nofollow"),v(G,"href","https://github.com/getify/You-Dont-Know-JS"),v(G,"rel","nofollow"),v(Y,"href","https://www.frontendinterviewhandbook.com/javascript-questions"),v(Y,"rel","nofollow")},m(e,r){c(e,T,r),l(T,$t),c(e,at,r),c(e,F,r),l(F,zt),c(e,st,r),c(e,Z,r),l(Z,Xt),c(e,it,r),c(e,$,r),l($,Qt),c(e,nt,r),c(e,z,r),l(z,Vt),c(e,rt,r),c(e,m,r),l(m,el),l(m,be),l(be,tl),l(m,ll),l(m,_e),l(_e,ol),l(m,al),l(m,Oe),l(Oe,sl),l(m,il),l(m,xe),l(xe,nl),l(m,rl),c(e,ct,r),c(e,X,r),l(X,cl),c(e,ft,r),c(e,W,r),W.innerHTML=bs,c(e,dt,r),c(e,Q,r),l(Q,fl),c(e,ut,r),c(e,h,r),l(h,dl),l(h,De),l(De,ul),l(h,pl),l(h,Ce),l(Ce,hl),l(h,vl),l(h,Te),l(Te,ml),l(h,yl),l(h,Ie),l(Ie,wl),l(h,El),l(h,Se),l(Se,bl),l(h,_l),l(h,q),l(q,Ol),l(h,xl),c(e,pt,r),c(e,I,r),l(I,Dl),l(I,ke),l(ke,Cl),l(I,Tl),c(e,ht,r),c(e,_,r),l(_,w),l(w,Il),l(w,Pe),l(Pe,Sl),l(w,kl),l(w,Ae),l(Ae,Pl),l(w,Al),l(w,He),l(He,Hl),l(w,Jl),l(_,Ll),l(_,E),l(E,Wl),l(E,Je),l(Je,ql),l(E,Nl),l(E,Le),l(Le,gl),l(E,Bl),l(E,We),l(We,Kl),l(E,Rl),l(_,Ml),l(_,b),l(b,jl),l(b,qe),l(qe,Ul),l(b,Gl),l(b,Ne),l(Ne,Yl),l(b,Fl),l(b,ge),l(ge,Zl),l(b,$l),c(e,vt,r),c(e,S,r),l(S,zl),l(S,Be),l(Be,Xl),l(S,Ql),c(e,mt,r),c(e,O,r),l(O,Vl),l(O,Ke),l(Ke,eo),l(O,to),l(O,Re),l(Re,lo),l(O,oo),c(e,yt,r),c(e,N,r),N.innerHTML=_s,c(e,wt,r),c(e,V,r),l(V,ao),c(e,Et,r),c(e,ee,r),l(ee,so),c(e,bt,r),c(e,te,r),l(te,C),l(C,io),l(C,Me),l(Me,no),l(C,ro),l(C,je),l(je,co),l(C,fo),c(e,_t,r),c(e,k,r),l(k,uo),l(k,Ue),l(Ue,po),l(k,ho),c(e,Ot,r),c(e,P,r),l(P,vo),l(P,Ge),l(Ge,mo),l(P,yo),c(e,xt,r),c(e,g,r),g.innerHTML=Os,c(e,Dt,r),c(e,A,r),l(A,wo),l(A,Ye),l(Ye,Eo),l(A,bo),c(e,Ct,r),c(e,B,r),B.innerHTML=xs,c(e,Tt,r),c(e,le,r),l(le,_o),c(e,It,r),c(e,oe,r),l(oe,Oo),c(e,St,r),c(e,ae,r),l(ae,xo),c(e,kt,r),c(e,se,r),l(se,Do),c(e,Pt,r),c(e,ie,r),l(ie,Fe),l(Fe,Co),c(e,At,r),c(e,K,r),K.innerHTML=Ds,c(e,Ht,r),c(e,ne,r),l(ne,To),c(e,Jt,r),c(e,re,r),l(re,Io),c(e,Lt,r),c(e,ce,r),l(ce,Ze),l(Ze,So),c(e,Wt,r),c(e,fe,r),l(fe,ko),c(e,qt,r),c(e,R,r),R.innerHTML=Cs,c(e,Nt,r),c(e,de,r),l(de,Po),c(e,gt,r),c(e,M,r),M.innerHTML=Ts,c(e,Bt,r),c(e,u,r),l(u,Ao),l(u,$e),l($e,Ho),l(u,Jo),l(u,ze),l(ze,Lo),l(u,Wo),l(u,Xe),l(Xe,qo),l(u,No),l(u,Qe),l(Qe,go),l(u,Bo),l(u,Ve),l(Ve,Ko),l(u,Ro),l(u,et),l(et,Mo),l(u,jo),l(u,tt),l(tt,Uo),l(u,Go),l(u,lt),l(lt,Yo),l(u,Fo),l(u,ot),l(ot,Zo),l(u,$o),c(e,Kt,r),c(e,ue,r),l(ue,zo),c(e,Rt,r),c(e,pe,r),l(pe,Xo),c(e,Mt,r),c(e,x,r),l(x,j),l(j,Qo),l(j,U),l(U,Vo),l(j,ea),l(x,ta),l(x,he),l(he,la),l(he,G),l(G,oa),l(x,aa),l(x,ve),l(ve,Y),l(Y,sa),l(ve,ia)},p:ca,i:ca,o:ca,d(e){e&&t(T),e&&t(at),e&&t(F),e&&t(st),e&&t(Z),e&&t(it),e&&t($),e&&t(nt),e&&t(z),e&&t(rt),e&&t(m),e&&t(ct),e&&t(X),e&&t(ft),e&&t(W),e&&t(dt),e&&t(Q),e&&t(ut),e&&t(h),e&&t(pt),e&&t(I),e&&t(ht),e&&t(_),e&&t(vt),e&&t(S),e&&t(mt),e&&t(O),e&&t(yt),e&&t(N),e&&t(wt),e&&t(V),e&&t(Et),e&&t(ee),e&&t(bt),e&&t(te),e&&t(_t),e&&t(k),e&&t(Ot),e&&t(P),e&&t(xt),e&&t(g),e&&t(Dt),e&&t(A),e&&t(Ct),e&&t(B),e&&t(Tt),e&&t(le),e&&t(It),e&&t(oe),e&&t(St),e&&t(ae),e&&t(kt),e&&t(se),e&&t(Pt),e&&t(ie),e&&t(At),e&&t(K),e&&t(Ht),e&&t(ne),e&&t(Jt),e&&t(re),e&&t(Lt),e&&t(ce),e&&t(Wt),e&&t(fe),e&&t(qt),e&&t(R),e&&t(Nt),e&&t(de),e&&t(gt),e&&t(M),e&&t(Bt),e&&t(u),e&&t(Kt),e&&t(ue),e&&t(Rt),e&&t(pe),e&&t(Mt),e&&t(x)}}}const Bs={title:"i still don't know js",date:"2024-07-15T21:00:08.000Z"};class Ks extends Ls{constructor(T){super(),Ws(this,T,null,Ns,qs,{})}}export{Ks as default,Bs as metadata};
