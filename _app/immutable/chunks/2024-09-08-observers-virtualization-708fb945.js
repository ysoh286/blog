import{S as rl,i as ol,s as ll,e as o,t as a,a as n,c as l,b as s,d as i,f as r,g as c,k as b,h as u,j as e,n as eo}from"./index-794e8e40.js";function sl(Jo){let I,dt,Ve,O,ne,ut,ht,ce,ft,We,F,vt,Ne,H,bt,Be,j,mt,Ge,E,de,wt,pt,ue,Et,_t,V,gt,y,W,he,yt,It,Ot,N,fe,Lt,Mt,Dt,B,ve,zt,kt,Ke,D,Qo=`<code class="language-undefined">const options = &#123;
    root: null,
    rootMargin: &quot;0px&quot;,
    threshold: 1.0,
&#125;;

const callback = (entries, observer) =&gt; &#123;
    for (let entry of entries) &#123;
        if (entry.isIntersecting) &#123;
            // do stuff
        &#125;
        // other values available - bounding ClientRect, intersectionRatio, intersectionRect, rootBounds, target, time
    &#125;
&#125;

const observer = new IntersectionObserver(callback, options);</code>`,Ze,G,Tt,Je,_,be,qt,At,z,Ct,me,St,Pt,xt,L,Ut,we,Rt,Ft,h,K,pe,Ht,jt,Vt,Z,Ee,Wt,Nt,Bt,J,_e,Gt,Kt,Zt,Q,ge,Jt,Qt,Xt,X,ye,Yt,$t,er,Y,Ie,tr,rr,or,M,Oe,lr,sr,Le,ar,ir,Qe,k,Xo=`<code class="language-undefined">
const config = &#123;
    attributes: false,
    childList: false,
    characterData: true,
    subtree: true,
&#125;;

const callback = (mutationList, observer) =&gt; &#123;
    for (const mutation of mutationList) &#123;
        if (mutation.type === &#39;characterData&#39;) &#123;
            // do stuff when character data has changed
            ...
        &#125;
    &#125;
&#125;;

const observer = new MutationObserver(callback);

// observe node that will change and then cause mutations
observer.observe(document.getElementById(...), config);

// disconnect to stop observing
observer.disconnect();
</code>`,Xe,$,nr,Ye,g,T,cr,Me,dr,ur,hr,De,fr,vr,ze,br,$e,q,Yo=`<code class="language-undefined">const container = document.getElementById(&quot;container&quot;);

const resizeObserver = new ResizeObserver((entries) =&gt; &#123;
    for (const entry of entries) &#123;
        if (entry.contentBoxSize) &#123;
            // do something based on resize
        &#125;
    &#125;
&#125;);

resizeObserver.observe(container);
</code>`,et,ee,mr,tt,te,wr,rt,re,pr,ot,f,ke,Er,_r,Te,gr,yr,qe,Ir,Or,Ae,Lr,Mr,Ce,Dr,zr,Se,kr,lt,oe,Tr,st,v,A,qr,C,Ar,Cr,Sr,Pe,S,Pr,xr,xe,P,Ur,Rr,Ue,x,Fr,Hr,Re,U,jr,Vr,Fe,R,Wr;return{c(){I=o("p"),dt=a("This week’s progress:"),Ve=n(),O=o("ul"),ne=o("li"),ut=a("Still working through Evgenii Ray’s Front End Systems Design course - about 75% there. It’s been eye-opening to see how to code virtualization from scratch, and actually understanding what’s going on under the hood (I thought it was just lazy loading, but turns out no, it recycles elements!)"),ht=n(),ce=o("li"),ft=a("Using a queue in production to handle concurrent requests (reality is that it’s not really supposed to be on the front-end, but corners are cut due to tight deadlines, usual software engineering woes)"),We=n(),F=o("h3"),vt=a("Observers API"),Ne=n(),H=o("p"),bt=a("There are 3 observer APIs that are available to handle different situations. These are generally used for performance reasons instead of vanilla approaches (which involves event based solutions or causes reflow):"),Be=n(),j=o("h4"),mt=a("Intersection observer"),Ge=n(),E=o("ul"),de=o("li"),wt=a("This is used when you have a target and see whether something intersects with the target."),pt=n(),ue=o("li"),Et=a("Use cases include implementing UI virtualization, infinite scrolling, or lazy load components when user scrolls to a certain point or requires more data to be seen after a certain point. This can be used to track several entry elements where a single observer can be used."),_t=n(),V=o("li"),gt=a("options:"),y=o("ul"),W=o("li"),he=o("code"),yt=a("root"),It=a(": element used for checking visibility of the target (defaults to viewport)"),Ot=n(),N=o("li"),fe=o("code"),Lt=a("rootMargin"),Mt=a(": margin around the root (defaults to all 0)"),Dt=n(),B=o("li"),ve=o("code"),zt=a("threshold"),kt=a(": a value between 0 and 1 or an array if required to be fired at every value inside array (value of 1.0 means the whole element must be visible to be considered intersecting)"),Ke=n(),D=o("pre"),Ze=n(),G=o("h4"),Tt=a("Mutation observer"),Je=n(),_=o("ul"),be=o("li"),qt=a("This is used when we wish to track changes in the DOM tree."),At=n(),z=o("li"),Ct=a("A common use case for this is keyboard shortcuts that allow for rich text editing using "),me=o("code"),St=a("contenteditable"),Pt=a(" attribute on an element"),xt=n(),L=o("li"),Ut=a("The options available to track are (note all these are boolean, with the exception of "),we=o("code"),Rt=a("attributeFilter"),Ft=a("):"),h=o("ul"),K=o("li"),pe=o("code"),Ht=a("childList"),jt=a(": target’s children to be observed"),Vt=n(),Z=o("li"),Ee=o("code"),Wt=a("attributes"),Nt=a(": target’s attributes are to be observed"),Bt=n(),J=o("li"),_e=o("code"),Gt=a("characterData"),Kt=a(": target’s data are to be observed"),Zt=n(),Q=o("li"),ge=o("code"),Jt=a("subtree"),Qt=a(": target’s all descendants to be observed"),Xt=n(),X=o("li"),ye=o("code"),Yt=a("attributeOldValue"),$t=a(": whether to track previous attribute value before mutation occurs"),er=n(),Y=o("li"),Ie=o("code"),tr=a("characterDataOldValue"),rr=a(": whether to track previous data value before mutation occurs"),or=n(),M=o("li"),Oe=o("code"),lr=a("attributeFilter"),sr=a(" - sets list of attribute names to be observed, or else all are observed (unless stated "),Le=o("code"),ar=a("false"),ir=a(")"),Qe=n(),k=o("pre"),Xe=n(),$=o("h4"),nr=a("Resize observer"),Ye=n(),g=o("ul"),T=o("li"),cr=a("This is used for tracking a resized element and reacting to it if we need something more customary that cannot be achieved with CSS media queries or container queries. Although we have the "),Me=o("code"),dr=a("window.resize"),ur=a(" event, this is about 10x more performant and can be used on elements rather than just the window."),hr=n(),De=o("li"),fr=a("Did use this once in production to render 2 buttons whenever there’s not enough space available for users to see all their tabs in an application."),vr=n(),ze=o("li"),br=a("More commonly, we tend to reach for CSS media queries and container queries for building responsive layouts."),$e=n(),q=o("pre"),et=n(),ee=o("h3"),mr=a("Virtualization"),tt=n(),te=o("p"),wr=a(`What is virtualization? It’s a performance rendering technique used only show elements that are restricted to its screen or viewport via a ‘sliding window’.
As we know, rendering DOM elements is expensive, especially when we have 1000+ elements on the page (and even more crucial and lot smaller when on older or smaller devices like mobile phones).
The idea is to minimise the number of elements rendered in the DOM tree, the number of DOM mutations, and reduce CPU and memory usage to maintain the DOM tree.`),rt=n(),re=o("p"),pr=a("Main use cases:"),ot=n(),f=o("ul"),ke=o("li"),Er=a("Mobile applications, or just loading a lot of elements that cause performance issues"),_r=n(),Te=o("li"),gr=a(`Examples include table with lots of elements, large lists (thousand of elements or more)
Main steps:`),yr=n(),qe=o("li"),Ir=a("2 observers on the top and bottom, which will render the elements required and ‘recycle’ elements whenever user scrolls up or down"),Or=n(),Ae=o("li"),Lr=a("whenever user scrolls down, we render the next few items, but we recycle the top items that are now not in view to become bottom new items"),Mr=n(),Ce=o("li"),Dr=a("whenever user scrolls up, we do the opposite and recycle the bottom items and bring them to the top"),zr=n(),Se=o("li"),kr=a("update data and then update observers on the screen to render these new items"),lt=n(),oe=o("h3"),Tr=a("References"),st=n(),v=o("ul"),A=o("li"),qr=a("Evgenii Ray’s "),C=o("a"),Ar=a("Front End Systems Design"),Cr=a(" course on FrontEnd Masters"),Sr=n(),Pe=o("li"),S=o("a"),Pr=a("IntersectionObserver - MDN"),xr=n(),xe=o("li"),P=o("a"),Ur=a("MutationObserver - MDN"),Rr=n(),Ue=o("li"),x=o("a"),Fr=a("Getting To Know The MutationObserver API - Smashing Magazine"),Hr=n(),Re=o("li"),U=o("a"),jr=a("DOM spec on MutationObserver"),Vr=n(),Fe=o("li"),R=o("a"),Wr=a("ResizeObserver - MDN"),this.h()},l(t){I=l(t,"P",{});var d=s(I);dt=i(d,"This week’s progress:"),d.forEach(r),Ve=c(t),O=l(t,"UL",{});var at=s(O);ne=l(at,"LI",{});var to=s(ne);ut=i(to,"Still working through Evgenii Ray’s Front End Systems Design course - about 75% there. It’s been eye-opening to see how to code virtualization from scratch, and actually understanding what’s going on under the hood (I thought it was just lazy loading, but turns out no, it recycles elements!)"),to.forEach(r),ht=c(at),ce=l(at,"LI",{});var ro=s(ce);ft=i(ro,"Using a queue in production to handle concurrent requests (reality is that it’s not really supposed to be on the front-end, but corners are cut due to tight deadlines, usual software engineering woes)"),ro.forEach(r),at.forEach(r),We=c(t),F=l(t,"H3",{});var oo=s(F);vt=i(oo,"Observers API"),oo.forEach(r),Ne=c(t),H=l(t,"P",{});var lo=s(H);bt=i(lo,"There are 3 observer APIs that are available to handle different situations. These are generally used for performance reasons instead of vanilla approaches (which involves event based solutions or causes reflow):"),lo.forEach(r),Be=c(t),j=l(t,"H4",{});var so=s(j);mt=i(so,"Intersection observer"),so.forEach(r),Ge=c(t),E=l(t,"UL",{});var le=s(E);de=l(le,"LI",{});var ao=s(de);wt=i(ao,"This is used when you have a target and see whether something intersects with the target."),ao.forEach(r),pt=c(le),ue=l(le,"LI",{});var io=s(ue);Et=i(io,"Use cases include implementing UI virtualization, infinite scrolling, or lazy load components when user scrolls to a certain point or requires more data to be seen after a certain point. This can be used to track several entry elements where a single observer can be used."),io.forEach(r),_t=c(le),V=l(le,"LI",{});var Nr=s(V);gt=i(Nr,"options:"),y=l(Nr,"UL",{});var se=s(y);W=l(se,"LI",{});var Br=s(W);he=l(Br,"CODE",{});var no=s(he);yt=i(no,"root"),no.forEach(r),It=i(Br,": element used for checking visibility of the target (defaults to viewport)"),Br.forEach(r),Ot=c(se),N=l(se,"LI",{});var Gr=s(N);fe=l(Gr,"CODE",{});var co=s(fe);Lt=i(co,"rootMargin"),co.forEach(r),Mt=i(Gr,": margin around the root (defaults to all 0)"),Gr.forEach(r),Dt=c(se),B=l(se,"LI",{});var Kr=s(B);ve=l(Kr,"CODE",{});var uo=s(ve);zt=i(uo,"threshold"),uo.forEach(r),kt=i(Kr,": a value between 0 and 1 or an array if required to be fired at every value inside array (value of 1.0 means the whole element must be visible to be considered intersecting)"),Kr.forEach(r),se.forEach(r),Nr.forEach(r),le.forEach(r),Ke=c(t),D=l(t,"PRE",{class:!0});var $o=s(D);$o.forEach(r),Ze=c(t),G=l(t,"H4",{});var ho=s(G);Tt=i(ho,"Mutation observer"),ho.forEach(r),Je=c(t),_=l(t,"UL",{});var ae=s(_);be=l(ae,"LI",{});var fo=s(be);qt=i(fo,"This is used when we wish to track changes in the DOM tree."),fo.forEach(r),At=c(ae),z=l(ae,"LI",{});var it=s(z);Ct=i(it,"A common use case for this is keyboard shortcuts that allow for rich text editing using "),me=l(it,"CODE",{});var vo=s(me);St=i(vo,"contenteditable"),vo.forEach(r),Pt=i(it," attribute on an element"),it.forEach(r),xt=c(ae),L=l(ae,"LI",{});var He=s(L);Ut=i(He,"The options available to track are (note all these are boolean, with the exception of "),we=l(He,"CODE",{});var bo=s(we);Rt=i(bo,"attributeFilter"),bo.forEach(r),Ft=i(He,"):"),h=l(He,"UL",{});var m=s(h);K=l(m,"LI",{});var Zr=s(K);pe=l(Zr,"CODE",{});var mo=s(pe);Ht=i(mo,"childList"),mo.forEach(r),jt=i(Zr,": target’s children to be observed"),Zr.forEach(r),Vt=c(m),Z=l(m,"LI",{});var Jr=s(Z);Ee=l(Jr,"CODE",{});var wo=s(Ee);Wt=i(wo,"attributes"),wo.forEach(r),Nt=i(Jr,": target’s attributes are to be observed"),Jr.forEach(r),Bt=c(m),J=l(m,"LI",{});var Qr=s(J);_e=l(Qr,"CODE",{});var po=s(_e);Gt=i(po,"characterData"),po.forEach(r),Kt=i(Qr,": target’s data are to be observed"),Qr.forEach(r),Zt=c(m),Q=l(m,"LI",{});var Xr=s(Q);ge=l(Xr,"CODE",{});var Eo=s(ge);Jt=i(Eo,"subtree"),Eo.forEach(r),Qt=i(Xr,": target’s all descendants to be observed"),Xr.forEach(r),Xt=c(m),X=l(m,"LI",{});var Yr=s(X);ye=l(Yr,"CODE",{});var _o=s(ye);Yt=i(_o,"attributeOldValue"),_o.forEach(r),$t=i(Yr,": whether to track previous attribute value before mutation occurs"),Yr.forEach(r),er=c(m),Y=l(m,"LI",{});var $r=s(Y);Ie=l($r,"CODE",{});var go=s(Ie);tr=i(go,"characterDataOldValue"),go.forEach(r),rr=i($r,": whether to track previous data value before mutation occurs"),$r.forEach(r),or=c(m),M=l(m,"LI",{});var je=s(M);Oe=l(je,"CODE",{});var yo=s(Oe);lr=i(yo,"attributeFilter"),yo.forEach(r),sr=i(je," - sets list of attribute names to be observed, or else all are observed (unless stated "),Le=l(je,"CODE",{});var Io=s(Le);ar=i(Io,"false"),Io.forEach(r),ir=i(je,")"),je.forEach(r),m.forEach(r),He.forEach(r),ae.forEach(r),Qe=c(t),k=l(t,"PRE",{class:!0});var el=s(k);el.forEach(r),Xe=c(t),$=l(t,"H4",{});var Oo=s($);nr=i(Oo,"Resize observer"),Oo.forEach(r),Ye=c(t),g=l(t,"UL",{});var ie=s(g);T=l(ie,"LI",{});var nt=s(T);cr=i(nt,"This is used for tracking a resized element and reacting to it if we need something more customary that cannot be achieved with CSS media queries or container queries. Although we have the "),Me=l(nt,"CODE",{});var Lo=s(Me);dr=i(Lo,"window.resize"),Lo.forEach(r),ur=i(nt," event, this is about 10x more performant and can be used on elements rather than just the window."),nt.forEach(r),hr=c(ie),De=l(ie,"LI",{});var Mo=s(De);fr=i(Mo,"Did use this once in production to render 2 buttons whenever there’s not enough space available for users to see all their tabs in an application."),Mo.forEach(r),vr=c(ie),ze=l(ie,"LI",{});var Do=s(ze);br=i(Do,"More commonly, we tend to reach for CSS media queries and container queries for building responsive layouts."),Do.forEach(r),ie.forEach(r),$e=c(t),q=l(t,"PRE",{class:!0});var tl=s(q);tl.forEach(r),et=c(t),ee=l(t,"H3",{});var zo=s(ee);mr=i(zo,"Virtualization"),zo.forEach(r),tt=c(t),te=l(t,"P",{});var ko=s(te);wr=i(ko,`What is virtualization? It’s a performance rendering technique used only show elements that are restricted to its screen or viewport via a ‘sliding window’.
As we know, rendering DOM elements is expensive, especially when we have 1000+ elements on the page (and even more crucial and lot smaller when on older or smaller devices like mobile phones).
The idea is to minimise the number of elements rendered in the DOM tree, the number of DOM mutations, and reduce CPU and memory usage to maintain the DOM tree.`),ko.forEach(r),rt=c(t),re=l(t,"P",{});var To=s(re);pr=i(To,"Main use cases:"),To.forEach(r),ot=c(t),f=l(t,"UL",{});var w=s(f);ke=l(w,"LI",{});var qo=s(ke);Er=i(qo,"Mobile applications, or just loading a lot of elements that cause performance issues"),qo.forEach(r),_r=c(w),Te=l(w,"LI",{});var Ao=s(Te);gr=i(Ao,`Examples include table with lots of elements, large lists (thousand of elements or more)
Main steps:`),Ao.forEach(r),yr=c(w),qe=l(w,"LI",{});var Co=s(qe);Ir=i(Co,"2 observers on the top and bottom, which will render the elements required and ‘recycle’ elements whenever user scrolls up or down"),Co.forEach(r),Or=c(w),Ae=l(w,"LI",{});var So=s(Ae);Lr=i(So,"whenever user scrolls down, we render the next few items, but we recycle the top items that are now not in view to become bottom new items"),So.forEach(r),Mr=c(w),Ce=l(w,"LI",{});var Po=s(Ce);Dr=i(Po,"whenever user scrolls up, we do the opposite and recycle the bottom items and bring them to the top"),Po.forEach(r),zr=c(w),Se=l(w,"LI",{});var xo=s(Se);kr=i(xo,"update data and then update observers on the screen to render these new items"),xo.forEach(r),w.forEach(r),lt=c(t),oe=l(t,"H3",{});var Uo=s(oe);Tr=i(Uo,"References"),Uo.forEach(r),st=c(t),v=l(t,"UL",{});var p=s(v);A=l(p,"LI",{});var ct=s(A);qr=i(ct,"Evgenii Ray’s "),C=l(ct,"A",{href:!0,rel:!0});var Ro=s(C);Ar=i(Ro,"Front End Systems Design"),Ro.forEach(r),Cr=i(ct," course on FrontEnd Masters"),ct.forEach(r),Sr=c(p),Pe=l(p,"LI",{});var Fo=s(Pe);S=l(Fo,"A",{href:!0,rel:!0});var Ho=s(S);Pr=i(Ho,"IntersectionObserver - MDN"),Ho.forEach(r),Fo.forEach(r),xr=c(p),xe=l(p,"LI",{});var jo=s(xe);P=l(jo,"A",{href:!0,rel:!0});var Vo=s(P);Ur=i(Vo,"MutationObserver - MDN"),Vo.forEach(r),jo.forEach(r),Rr=c(p),Ue=l(p,"LI",{});var Wo=s(Ue);x=l(Wo,"A",{href:!0,rel:!0});var No=s(x);Fr=i(No,"Getting To Know The MutationObserver API - Smashing Magazine"),No.forEach(r),Wo.forEach(r),Hr=c(p),Re=l(p,"LI",{});var Bo=s(Re);U=l(Bo,"A",{href:!0,rel:!0});var Go=s(U);jr=i(Go,"DOM spec on MutationObserver"),Go.forEach(r),Bo.forEach(r),Vr=c(p),Fe=l(p,"LI",{});var Ko=s(Fe);R=l(Ko,"A",{href:!0,rel:!0});var Zo=s(R);Wr=i(Zo,"ResizeObserver - MDN"),Zo.forEach(r),Ko.forEach(r),p.forEach(r),this.h()},h(){b(D,"class","language-undefined"),b(k,"class","language-undefined"),b(q,"class","language-undefined"),b(C,"href","https://frontendmasters.com/courses/frontend-system-design/"),b(C,"rel","nofollow"),b(S,"href","https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API"),b(S,"rel","nofollow"),b(P,"href","https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver"),b(P,"rel","nofollow"),b(x,"href","https://www.smashingmagazine.com/2019/04/mutationobserver-api-guide/"),b(x,"rel","nofollow"),b(U,"href","https://dom.spec.whatwg.org/#interface-mutationobserver"),b(U,"rel","nofollow"),b(R,"href","https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver"),b(R,"rel","nofollow")},m(t,d){u(t,I,d),e(I,dt),u(t,Ve,d),u(t,O,d),e(O,ne),e(ne,ut),e(O,ht),e(O,ce),e(ce,ft),u(t,We,d),u(t,F,d),e(F,vt),u(t,Ne,d),u(t,H,d),e(H,bt),u(t,Be,d),u(t,j,d),e(j,mt),u(t,Ge,d),u(t,E,d),e(E,de),e(de,wt),e(E,pt),e(E,ue),e(ue,Et),e(E,_t),e(E,V),e(V,gt),e(V,y),e(y,W),e(W,he),e(he,yt),e(W,It),e(y,Ot),e(y,N),e(N,fe),e(fe,Lt),e(N,Mt),e(y,Dt),e(y,B),e(B,ve),e(ve,zt),e(B,kt),u(t,Ke,d),u(t,D,d),D.innerHTML=Qo,u(t,Ze,d),u(t,G,d),e(G,Tt),u(t,Je,d),u(t,_,d),e(_,be),e(be,qt),e(_,At),e(_,z),e(z,Ct),e(z,me),e(me,St),e(z,Pt),e(_,xt),e(_,L),e(L,Ut),e(L,we),e(we,Rt),e(L,Ft),e(L,h),e(h,K),e(K,pe),e(pe,Ht),e(K,jt),e(h,Vt),e(h,Z),e(Z,Ee),e(Ee,Wt),e(Z,Nt),e(h,Bt),e(h,J),e(J,_e),e(_e,Gt),e(J,Kt),e(h,Zt),e(h,Q),e(Q,ge),e(ge,Jt),e(Q,Qt),e(h,Xt),e(h,X),e(X,ye),e(ye,Yt),e(X,$t),e(h,er),e(h,Y),e(Y,Ie),e(Ie,tr),e(Y,rr),e(h,or),e(h,M),e(M,Oe),e(Oe,lr),e(M,sr),e(M,Le),e(Le,ar),e(M,ir),u(t,Qe,d),u(t,k,d),k.innerHTML=Xo,u(t,Xe,d),u(t,$,d),e($,nr),u(t,Ye,d),u(t,g,d),e(g,T),e(T,cr),e(T,Me),e(Me,dr),e(T,ur),e(g,hr),e(g,De),e(De,fr),e(g,vr),e(g,ze),e(ze,br),u(t,$e,d),u(t,q,d),q.innerHTML=Yo,u(t,et,d),u(t,ee,d),e(ee,mr),u(t,tt,d),u(t,te,d),e(te,wr),u(t,rt,d),u(t,re,d),e(re,pr),u(t,ot,d),u(t,f,d),e(f,ke),e(ke,Er),e(f,_r),e(f,Te),e(Te,gr),e(f,yr),e(f,qe),e(qe,Ir),e(f,Or),e(f,Ae),e(Ae,Lr),e(f,Mr),e(f,Ce),e(Ce,Dr),e(f,zr),e(f,Se),e(Se,kr),u(t,lt,d),u(t,oe,d),e(oe,Tr),u(t,st,d),u(t,v,d),e(v,A),e(A,qr),e(A,C),e(C,Ar),e(A,Cr),e(v,Sr),e(v,Pe),e(Pe,S),e(S,Pr),e(v,xr),e(v,xe),e(xe,P),e(P,Ur),e(v,Rr),e(v,Ue),e(Ue,x),e(x,Fr),e(v,Hr),e(v,Re),e(Re,U),e(U,jr),e(v,Vr),e(v,Fe),e(Fe,R),e(R,Wr)},p:eo,i:eo,o:eo,d(t){t&&r(I),t&&r(Ve),t&&r(O),t&&r(We),t&&r(F),t&&r(Ne),t&&r(H),t&&r(Be),t&&r(j),t&&r(Ge),t&&r(E),t&&r(Ke),t&&r(D),t&&r(Ze),t&&r(G),t&&r(Je),t&&r(_),t&&r(Qe),t&&r(k),t&&r(Xe),t&&r($),t&&r(Ye),t&&r(g),t&&r($e),t&&r(q),t&&r(et),t&&r(ee),t&&r(tt),t&&r(te),t&&r(rt),t&&r(re),t&&r(ot),t&&r(f),t&&r(lt),t&&r(oe),t&&r(st),t&&r(v)}}}const il={title:"Weekly learning review - Observers Web API, Virtualization",date:"2024-09-08T22:15:00.000Z"};class nl extends rl{constructor(I){super(),ol(this,I,null,sl,ll,{})}}export{nl as default,il as metadata};
