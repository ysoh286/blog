import{S as kn,i as yn,s as Tn,e as s,t as i,a as r,c as n,b as l,d as a,f as o,g as c,k as u,h,j as e,n as ds}from"./index-794e8e40.js";function In(hn){let y,kt,Ve,E,S,yt,re,Tt,It,Lt,ce,St,Pt,de,qt,je,Z,Ct,Ge,_,he,Ht,At,ue,Rt,xt,P,Dt,fe,Nt,Ut,Je,q,un=`<code class="language-undefined">setInterval(() =&gt; &#123;
    fetch(api, params).then(doSomething);
&#125;, timeout);</code>`,Ke,X,C,Wt,me,Mt,Ot,Qe,H,fn=`<code class="language-undefined">const INTERVAL_SECONDS = 30;

const runRequest = () =&gt; &#123;
    // do stuff
    ...
    setTimeout(runRequest, INTERVAL_SECONDS);
&#125;;

runRequest();</code>`,Ze,T,ve,Ft,zt,A,Bt,pe,Vt,jt,Xe,R,mn=`<code class="language-undefined">// taken and adapted from Brian Holt&#39;s real-time course

setTimeout(runRequest, INTERVAL_SECONDS);

let timeToNextRequest = 0;
const timer = async(time) &#123;
    if (timeToNextRequest &lt;= time) &#123;
        await runRequest();
        timeToNextRequest = time + INTERVAL_SECONDS;
    &#125;
    requestAnimationFrame(timer);
&#125;

requestAnimationFrame(timer);
</code>`,Ye,g,we,Gt,Jt,Y,Kt,b,be,Qt,Zt,Ee,Xt,Yt,_e,$t,eo,ge,to,oo,ke,so,$e,$,no,et,ee,ye,lo,tt,I,x,io,Te,ao,ro,co,Ie,ho,ot,D,vn=`<code class="language-undefined">const source = new EventSource(&quot;url/to-receive-data-from&quot;, &#123; withCredentials: true &#125;);

source.onmessage = (event) =&gt; &#123;
  // do something when message comes through
&#125;;

source.onerror = (err) =&gt; &#123;
    // do something when error occurs
&#125;

source.addEventListener(&quot;customEvent&quot;, (event) =&gt; &#123;
    // do something when custom event occurs
&#125;);

// close event stream / connection between client and server
source.close();</code>`,st,m,Le,uo,fo,Se,mo,vo,Pe,po,wo,qe,bo,Eo,Ce,_o,go,He,ko,yo,Ae,To,nt,te,Io,lt,p,Re,Lo,So,xe,Po,qo,De,Co,Ho,Ne,Ao,Ro,N,xo,Ue,Do,No,it,U,pn=`<code class="language-undefined">const websocket = new WebSocket(&quot;wss://url-to-web-socket&quot;, protocols);

// send data to server
websocket.send(&quot;Some text to send across!&quot;);

websocket.onopen = (event) =&gt; &#123;
    // do something when websocket connection is established and open
&#125;

// to receive messages from server
websocket.onmessage = (event) =&gt; &#123;
    // do something with message (event.data)
&#125;

// close the connection
websocket.close();
</code>`,at,oe,Uo,rt,se,Wo,ct,ne,Mo,dt,f,W,Oo,M,Fo,zo,Bo,O,Vo,F,jo,Go,Jo,z,Ko,B,Qo,Zo,Xo,We,V,Yo,$o,Me,j,es,ts,Oe,G,os,ss,Fe,J,ns,ls,ze,K,is,as,Be,Q,rs;return{c(){y=s("p"),kt=i("This week’s progress:"),Ve=r(),E=s("ul"),S=s("li"),yt=i("Weirdly enough, at work had to explore "),re=s("code"),Tt=i("ResizeObserver"),It=i(" in a bit more detail for a certain feature. Still yet to crack, investigate and see if we can stretch it to make it more performant, but it was great to be able to put some learnings from last week into action."),Lt=r(),ce=s("li"),St=i("Completed Evgenii Ray’s System Design course - it opened up a lot of things I didn’t know or took for granted (such as bundlers and why we need bundlers, web sockets for real time communication, HTTP1 / HTTP2 protocols, normalization of data actually being helpful on the front-end and how to approach a front-end system design interview)"),Pt=r(),de=s("li"),qt=i("Although much was covered, the most interesting part for the week was web sockets, server sent events, and long polling."),je=r(),Z=s("h3"),Ct=i("Long polling"),Ge=r(),_=s("ul"),he=s("li"),Ht=i("Long polling is just making lots of network requests every few seconds."),At=r(),ue=s("li"),Rt=i("Short polling is generally 5-10 seconds, while long polling could be something like every 30 seconds."),xt=r(),P=s("li"),Dt=i("This can be achieved and easily implemented using "),fe=s("code"),Nt=i("setInterval"),Ut=i(", but it does not guarantee that it will run or if in the situation where the function that runs takes longer than the timeout, then it will never complete."),Je=r(),q=s("pre"),Ke=r(),X=s("ul"),C=s("li"),Wt=i("A different alternative to implement this is to use "),me=s("code"),Mt=i("setTimeout"),Ot=i(", and start timer for request as soon as it is made / complete."),Qe=r(),H=s("pre"),Ze=r(),T=s("ul"),ve=s("li"),Ft=i("In situations, you may only want to only run this when the user is active on the page, however in other cases we might not want that and constantly poll."),zt=r(),A=s("li"),Bt=i("If there is a need to pause when user moves away, consider using "),pe=s("code"),Vt=i("requestAnimationFrame"),jt=i(", which runs when the main JavaScript thread is idle and guarantees no interruptions of repaints"),Xe=r(),R=s("pre"),Ye=r(),g=s("ul"),we=s("li"),Gt=i("If at any point it fails, we should consider exponential backoff for retrying and re-establishing the network connection"),Jt=r(),Y=s("li"),Kt=i("Downsides of long polling:"),b=s("ul"),be=s("li"),Qt=i("takes alot of time to establish the connection (costs CPU and drains energy to maintain the TCP HTTP1 connection)"),Zt=r(),Ee=s("li"),Xt=i("inefficient as we need to send header data every time in each request"),Yt=r(),_e=s("li"),$t=i("drains mobile devices significantly to maintain the TCP connection due to receiving and sending data constantly"),eo=r(),ge=s("li"),to=i("latency issues (reconnection required, server also needs to keep state and reconnection is required to be implemented on the client)"),oo=r(),ke=s("li"),so=i("This can be used on desktop applications, but NOT recommended for applications on other devices with limited CPU or mobile applications"),$e=r(),$=s("h3"),no=i("Server sent events"),et=r(),ee=s("blockquote"),ye=s("p"),lo=i("Traditionally, web page would send a request to server and receive new data. With server sent events, the server sends new data to a web page at any time by pushing messages to the web page. - MDN"),tt=r(),I=s("ul"),x=s("li"),io=i("In order to achieve this, we can use "),Te=s("code"),ao=i("EventSource"),ro=i(" interface which allows us to handle the messages as events on the frontend."),co=r(),Ie=s("li"),ho=i("Streams should be text data and encoded as UTF-8"),ot=r(),D=s("pre"),st=r(),m=s("ul"),Le=s("li"),uo=i("Note that this should NOT be used on HTTP1, as this will suffer from limitation of maximum number of open connections (HTTP1 has maximum of 5 connections, while HTTP2 has up to 200)"),fo=r(),Se=s("li"),mo=i("Communication is established on initial connection, while the rest of the connection involves server pushing data to the client which is handled for us"),vo=r(),Pe=s("li"),po=i("Does not need to send headers all the time (which reduces amount of overhead required)"),wo=r(),qe=s("li"),bo=i("Reconnection is handled automatically for us (and on HTTP2 it reuses the existing TCP connection), and easy to scale"),Eo=r(),Ce=s("li"),_o=i("This is much more efficient compared to short/long polling, easy to scale, minimal network overhead and has good performance"),go=r(),He=s("li"),ko=i("However, we cannot push data to the server and only text is supported"),yo=r(),Ae=s("li"),To=i("Recommended to be used for complex desktop / web applications, or as an alternative to web-sockets where some latency is acceptable. However, if we have a simple desktop app, we can use long polling instead"),nt=r(),te=s("h3"),Io=i("Web sockets"),lt=r(),p=s("ul"),Re=s("li"),Lo=i("Generally when we think real-time communication, we reach for web-sockets"),So=r(),xe=s("li"),Po=i("A normal TCP/IP connection is created that allows client and server to push messages back and forth, which is requested to become a socket connection via a ‘handshake’ request (when server responds with succesful request, browser upgrades protocol to web sockets)"),qo=r(),De=s("li"),Co=i("An unlimited number of connections can be made once the web-socket has been established"),Ho=r(),Ne=s("li"),Ao=i("However, it’s a bit of a misconception to always reach for this as the solution for all real-time communication as this is hard to maintain (more complex infrastructure), very expensive, and requires a constant TCP connection to be maintained which drains CPU"),Ro=r(),N=s("li"),xo=i("Consider using "),Ue=s("code"),Do=i("socket.io"),No=i(" for implementing web sockets, or the native Web Socket API (more complex as you’ll need to implement reconnection yourself, and consider falling back to long polling if web sockets is not supported in the browser)"),it=r(),U=s("pre"),at=r(),oe=s("p"),Uo=i("Which to choose for which scenario?"),rt=r(),se=s("p"),Wo=i("SSE is generally favoured over web-sockets if we only need to send data from server to client all the time, while in simple cases you can use short/long polling for desktop applications, while SSE works for mobile applications. SSE’s performance is close to web sockets, and such that if our users do not mind a small latency tradeoff, SSE can be the solution. However, if you do require the need to constantly send messages / data back and forth between client and server, web sockets are the way to go."),ct=r(),ne=s("h3"),Mo=i("References"),dt=r(),f=s("ul"),W=s("li"),Oo=i("Evgenii Ray’s "),M=s("a"),Fo=i("Front End Systems Design"),zo=i(" course on FrontEnd Masters"),Bo=r(),O=s("li"),Vo=i("Brian Holt’s "),F=s("a"),jo=i("Complete Intro to Real-Time"),Go=i(" course on FrontEnd Masters"),Jo=r(),z=s("li"),Ko=i("Brian Holt’s "),B=s("a"),Qo=i("Complete Intro to Real-Time"),Zo=i(" course website"),Xo=r(),We=s("li"),V=s("a"),Yo=i("Server sent events - MDN"),$o=r(),Me=s("li"),j=s("a"),es=i("Using server sent events - MDN"),ts=r(),Oe=s("li"),G=s("a"),os=i("Stream updates with server sent events - web.dev"),ss=r(),Fe=s("li"),J=s("a"),ns=i("Server-sent events - HTML Spec"),ls=r(),ze=s("li"),K=s("a"),is=i("WebSocket API - MDN"),as=r(),Be=s("li"),Q=s("a"),rs=i("Writing web socket applications - MDN"),this.h()},l(t){y=n(t,"P",{});var d=l(y);kt=a(d,"This week’s progress:"),d.forEach(o),Ve=c(t),E=n(t,"UL",{});var le=l(E);S=n(le,"LI",{});var ht=l(S);yt=a(ht,"Weirdly enough, at work had to explore "),re=n(ht,"CODE",{});var hs=l(re);Tt=a(hs,"ResizeObserver"),hs.forEach(o),It=a(ht," in a bit more detail for a certain feature. Still yet to crack, investigate and see if we can stretch it to make it more performant, but it was great to be able to put some learnings from last week into action."),ht.forEach(o),Lt=c(le),ce=n(le,"LI",{});var us=l(ce);St=a(us,"Completed Evgenii Ray’s System Design course - it opened up a lot of things I didn’t know or took for granted (such as bundlers and why we need bundlers, web sockets for real time communication, HTTP1 / HTTP2 protocols, normalization of data actually being helpful on the front-end and how to approach a front-end system design interview)"),us.forEach(o),Pt=c(le),de=n(le,"LI",{});var fs=l(de);qt=a(fs,"Although much was covered, the most interesting part for the week was web sockets, server sent events, and long polling."),fs.forEach(o),le.forEach(o),je=c(t),Z=n(t,"H3",{});var ms=l(Z);Ct=a(ms,"Long polling"),ms.forEach(o),Ge=c(t),_=n(t,"UL",{});var ie=l(_);he=n(ie,"LI",{});var vs=l(he);Ht=a(vs,"Long polling is just making lots of network requests every few seconds."),vs.forEach(o),At=c(ie),ue=n(ie,"LI",{});var ps=l(ue);Rt=a(ps,"Short polling is generally 5-10 seconds, while long polling could be something like every 30 seconds."),ps.forEach(o),xt=c(ie),P=n(ie,"LI",{});var ut=l(P);Dt=a(ut,"This can be achieved and easily implemented using "),fe=n(ut,"CODE",{});var ws=l(fe);Nt=a(ws,"setInterval"),ws.forEach(o),Ut=a(ut,", but it does not guarantee that it will run or if in the situation where the function that runs takes longer than the timeout, then it will never complete."),ut.forEach(o),ie.forEach(o),Je=c(t),q=n(t,"PRE",{class:!0});var wn=l(q);wn.forEach(o),Ke=c(t),X=n(t,"UL",{});var bs=l(X);C=n(bs,"LI",{});var ft=l(C);Wt=a(ft,"A different alternative to implement this is to use "),me=n(ft,"CODE",{});var Es=l(me);Mt=a(Es,"setTimeout"),Es.forEach(o),Ot=a(ft,", and start timer for request as soon as it is made / complete."),ft.forEach(o),bs.forEach(o),Qe=c(t),H=n(t,"PRE",{class:!0});var bn=l(H);bn.forEach(o),Ze=c(t),T=n(t,"UL",{});var mt=l(T);ve=n(mt,"LI",{});var _s=l(ve);Ft=a(_s,"In situations, you may only want to only run this when the user is active on the page, however in other cases we might not want that and constantly poll."),_s.forEach(o),zt=c(mt),A=n(mt,"LI",{});var vt=l(A);Bt=a(vt,"If there is a need to pause when user moves away, consider using "),pe=n(vt,"CODE",{});var gs=l(pe);Vt=a(gs,"requestAnimationFrame"),gs.forEach(o),jt=a(vt,", which runs when the main JavaScript thread is idle and guarantees no interruptions of repaints"),vt.forEach(o),mt.forEach(o),Xe=c(t),R=n(t,"PRE",{class:!0});var En=l(R);En.forEach(o),Ye=c(t),g=n(t,"UL",{});var ae=l(g);we=n(ae,"LI",{});var ks=l(we);Gt=a(ks,"If at any point it fails, we should consider exponential backoff for retrying and re-establishing the network connection"),ks.forEach(o),Jt=c(ae),Y=n(ae,"LI",{});var cs=l(Y);Kt=a(cs,"Downsides of long polling:"),b=n(cs,"UL",{});var L=l(b);be=n(L,"LI",{});var ys=l(be);Qt=a(ys,"takes alot of time to establish the connection (costs CPU and drains energy to maintain the TCP HTTP1 connection)"),ys.forEach(o),Zt=c(L),Ee=n(L,"LI",{});var Ts=l(Ee);Xt=a(Ts,"inefficient as we need to send header data every time in each request"),Ts.forEach(o),Yt=c(L),_e=n(L,"LI",{});var Is=l(_e);$t=a(Is,"drains mobile devices significantly to maintain the TCP connection due to receiving and sending data constantly"),Is.forEach(o),eo=c(L),ge=n(L,"LI",{});var Ls=l(ge);to=a(Ls,"latency issues (reconnection required, server also needs to keep state and reconnection is required to be implemented on the client)"),Ls.forEach(o),L.forEach(o),cs.forEach(o),oo=c(ae),ke=n(ae,"LI",{});var Ss=l(ke);so=a(Ss,"This can be used on desktop applications, but NOT recommended for applications on other devices with limited CPU or mobile applications"),Ss.forEach(o),ae.forEach(o),$e=c(t),$=n(t,"H3",{});var Ps=l($);no=a(Ps,"Server sent events"),Ps.forEach(o),et=c(t),ee=n(t,"BLOCKQUOTE",{});var qs=l(ee);ye=n(qs,"P",{});var Cs=l(ye);lo=a(Cs,"Traditionally, web page would send a request to server and receive new data. With server sent events, the server sends new data to a web page at any time by pushing messages to the web page. - MDN"),Cs.forEach(o),qs.forEach(o),tt=c(t),I=n(t,"UL",{});var pt=l(I);x=n(pt,"LI",{});var wt=l(x);io=a(wt,"In order to achieve this, we can use "),Te=n(wt,"CODE",{});var Hs=l(Te);ao=a(Hs,"EventSource"),Hs.forEach(o),ro=a(wt," interface which allows us to handle the messages as events on the frontend."),wt.forEach(o),co=c(pt),Ie=n(pt,"LI",{});var As=l(Ie);ho=a(As,"Streams should be text data and encoded as UTF-8"),As.forEach(o),pt.forEach(o),ot=c(t),D=n(t,"PRE",{class:!0});var _n=l(D);_n.forEach(o),st=c(t),m=n(t,"UL",{});var w=l(m);Le=n(w,"LI",{});var Rs=l(Le);uo=a(Rs,"Note that this should NOT be used on HTTP1, as this will suffer from limitation of maximum number of open connections (HTTP1 has maximum of 5 connections, while HTTP2 has up to 200)"),Rs.forEach(o),fo=c(w),Se=n(w,"LI",{});var xs=l(Se);mo=a(xs,"Communication is established on initial connection, while the rest of the connection involves server pushing data to the client which is handled for us"),xs.forEach(o),vo=c(w),Pe=n(w,"LI",{});var Ds=l(Pe);po=a(Ds,"Does not need to send headers all the time (which reduces amount of overhead required)"),Ds.forEach(o),wo=c(w),qe=n(w,"LI",{});var Ns=l(qe);bo=a(Ns,"Reconnection is handled automatically for us (and on HTTP2 it reuses the existing TCP connection), and easy to scale"),Ns.forEach(o),Eo=c(w),Ce=n(w,"LI",{});var Us=l(Ce);_o=a(Us,"This is much more efficient compared to short/long polling, easy to scale, minimal network overhead and has good performance"),Us.forEach(o),go=c(w),He=n(w,"LI",{});var Ws=l(He);ko=a(Ws,"However, we cannot push data to the server and only text is supported"),Ws.forEach(o),yo=c(w),Ae=n(w,"LI",{});var Ms=l(Ae);To=a(Ms,"Recommended to be used for complex desktop / web applications, or as an alternative to web-sockets where some latency is acceptable. However, if we have a simple desktop app, we can use long polling instead"),Ms.forEach(o),w.forEach(o),nt=c(t),te=n(t,"H3",{});var Os=l(te);Io=a(Os,"Web sockets"),Os.forEach(o),lt=c(t),p=n(t,"UL",{});var k=l(p);Re=n(k,"LI",{});var Fs=l(Re);Lo=a(Fs,"Generally when we think real-time communication, we reach for web-sockets"),Fs.forEach(o),So=c(k),xe=n(k,"LI",{});var zs=l(xe);Po=a(zs,"A normal TCP/IP connection is created that allows client and server to push messages back and forth, which is requested to become a socket connection via a ‘handshake’ request (when server responds with succesful request, browser upgrades protocol to web sockets)"),zs.forEach(o),qo=c(k),De=n(k,"LI",{});var Bs=l(De);Co=a(Bs,"An unlimited number of connections can be made once the web-socket has been established"),Bs.forEach(o),Ho=c(k),Ne=n(k,"LI",{});var Vs=l(Ne);Ao=a(Vs,"However, it’s a bit of a misconception to always reach for this as the solution for all real-time communication as this is hard to maintain (more complex infrastructure), very expensive, and requires a constant TCP connection to be maintained which drains CPU"),Vs.forEach(o),Ro=c(k),N=n(k,"LI",{});var bt=l(N);xo=a(bt,"Consider using "),Ue=n(bt,"CODE",{});var js=l(Ue);Do=a(js,"socket.io"),js.forEach(o),No=a(bt," for implementing web sockets, or the native Web Socket API (more complex as you’ll need to implement reconnection yourself, and consider falling back to long polling if web sockets is not supported in the browser)"),bt.forEach(o),k.forEach(o),it=c(t),U=n(t,"PRE",{class:!0});var gn=l(U);gn.forEach(o),at=c(t),oe=n(t,"P",{});var Gs=l(oe);Uo=a(Gs,"Which to choose for which scenario?"),Gs.forEach(o),rt=c(t),se=n(t,"P",{});var Js=l(se);Wo=a(Js,"SSE is generally favoured over web-sockets if we only need to send data from server to client all the time, while in simple cases you can use short/long polling for desktop applications, while SSE works for mobile applications. SSE’s performance is close to web sockets, and such that if our users do not mind a small latency tradeoff, SSE can be the solution. However, if you do require the need to constantly send messages / data back and forth between client and server, web sockets are the way to go."),Js.forEach(o),ct=c(t),ne=n(t,"H3",{});var Ks=l(ne);Mo=a(Ks,"References"),Ks.forEach(o),dt=c(t),f=n(t,"UL",{});var v=l(f);W=n(v,"LI",{});var Et=l(W);Oo=a(Et,"Evgenii Ray’s "),M=n(Et,"A",{href:!0,rel:!0});var Qs=l(M);Fo=a(Qs,"Front End Systems Design"),Qs.forEach(o),zo=a(Et," course on FrontEnd Masters"),Et.forEach(o),Bo=c(v),O=n(v,"LI",{});var _t=l(O);Vo=a(_t,"Brian Holt’s "),F=n(_t,"A",{href:!0,rel:!0});var Zs=l(F);jo=a(Zs,"Complete Intro to Real-Time"),Zs.forEach(o),Go=a(_t," course on FrontEnd Masters"),_t.forEach(o),Jo=c(v),z=n(v,"LI",{});var gt=l(z);Ko=a(gt,"Brian Holt’s "),B=n(gt,"A",{href:!0,rel:!0});var Xs=l(B);Qo=a(Xs,"Complete Intro to Real-Time"),Xs.forEach(o),Zo=a(gt," course website"),gt.forEach(o),Xo=c(v),We=n(v,"LI",{});var Ys=l(We);V=n(Ys,"A",{href:!0,rel:!0});var $s=l(V);Yo=a($s,"Server sent events - MDN"),$s.forEach(o),Ys.forEach(o),$o=c(v),Me=n(v,"LI",{});var en=l(Me);j=n(en,"A",{href:!0,rel:!0});var tn=l(j);es=a(tn,"Using server sent events - MDN"),tn.forEach(o),en.forEach(o),ts=c(v),Oe=n(v,"LI",{});var on=l(Oe);G=n(on,"A",{href:!0,rel:!0});var sn=l(G);os=a(sn,"Stream updates with server sent events - web.dev"),sn.forEach(o),on.forEach(o),ss=c(v),Fe=n(v,"LI",{});var nn=l(Fe);J=n(nn,"A",{href:!0,rel:!0});var ln=l(J);ns=a(ln,"Server-sent events - HTML Spec"),ln.forEach(o),nn.forEach(o),ls=c(v),ze=n(v,"LI",{});var an=l(ze);K=n(an,"A",{href:!0,rel:!0});var rn=l(K);is=a(rn,"WebSocket API - MDN"),rn.forEach(o),an.forEach(o),as=c(v),Be=n(v,"LI",{});var cn=l(Be);Q=n(cn,"A",{href:!0,rel:!0});var dn=l(Q);rs=a(dn,"Writing web socket applications - MDN"),dn.forEach(o),cn.forEach(o),v.forEach(o),this.h()},h(){u(q,"class","language-undefined"),u(H,"class","language-undefined"),u(R,"class","language-undefined"),u(D,"class","language-undefined"),u(U,"class","language-undefined"),u(M,"href","https://frontendmasters.com/courses/frontend-system-design/"),u(M,"rel","nofollow"),u(F,"href","https://frontendmasters.com/courses/realtime/"),u(F,"rel","nofollow"),u(B,"href","https://btholt.github.io/complete-intro-to-realtime/"),u(B,"rel","nofollow"),u(V,"href","https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events"),u(V,"rel","nofollow"),u(j,"href","https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events"),u(j,"rel","nofollow"),u(G,"href","https://web.dev/articles/eventsource-basics"),u(G,"rel","nofollow"),u(J,"href","https://html.spec.whatwg.org/multipage/server-sent-events.html"),u(J,"rel","nofollow"),u(K,"href","https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API"),u(K,"rel","nofollow"),u(Q,"href","https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_client_applications"),u(Q,"rel","nofollow")},m(t,d){h(t,y,d),e(y,kt),h(t,Ve,d),h(t,E,d),e(E,S),e(S,yt),e(S,re),e(re,Tt),e(S,It),e(E,Lt),e(E,ce),e(ce,St),e(E,Pt),e(E,de),e(de,qt),h(t,je,d),h(t,Z,d),e(Z,Ct),h(t,Ge,d),h(t,_,d),e(_,he),e(he,Ht),e(_,At),e(_,ue),e(ue,Rt),e(_,xt),e(_,P),e(P,Dt),e(P,fe),e(fe,Nt),e(P,Ut),h(t,Je,d),h(t,q,d),q.innerHTML=un,h(t,Ke,d),h(t,X,d),e(X,C),e(C,Wt),e(C,me),e(me,Mt),e(C,Ot),h(t,Qe,d),h(t,H,d),H.innerHTML=fn,h(t,Ze,d),h(t,T,d),e(T,ve),e(ve,Ft),e(T,zt),e(T,A),e(A,Bt),e(A,pe),e(pe,Vt),e(A,jt),h(t,Xe,d),h(t,R,d),R.innerHTML=mn,h(t,Ye,d),h(t,g,d),e(g,we),e(we,Gt),e(g,Jt),e(g,Y),e(Y,Kt),e(Y,b),e(b,be),e(be,Qt),e(b,Zt),e(b,Ee),e(Ee,Xt),e(b,Yt),e(b,_e),e(_e,$t),e(b,eo),e(b,ge),e(ge,to),e(g,oo),e(g,ke),e(ke,so),h(t,$e,d),h(t,$,d),e($,no),h(t,et,d),h(t,ee,d),e(ee,ye),e(ye,lo),h(t,tt,d),h(t,I,d),e(I,x),e(x,io),e(x,Te),e(Te,ao),e(x,ro),e(I,co),e(I,Ie),e(Ie,ho),h(t,ot,d),h(t,D,d),D.innerHTML=vn,h(t,st,d),h(t,m,d),e(m,Le),e(Le,uo),e(m,fo),e(m,Se),e(Se,mo),e(m,vo),e(m,Pe),e(Pe,po),e(m,wo),e(m,qe),e(qe,bo),e(m,Eo),e(m,Ce),e(Ce,_o),e(m,go),e(m,He),e(He,ko),e(m,yo),e(m,Ae),e(Ae,To),h(t,nt,d),h(t,te,d),e(te,Io),h(t,lt,d),h(t,p,d),e(p,Re),e(Re,Lo),e(p,So),e(p,xe),e(xe,Po),e(p,qo),e(p,De),e(De,Co),e(p,Ho),e(p,Ne),e(Ne,Ao),e(p,Ro),e(p,N),e(N,xo),e(N,Ue),e(Ue,Do),e(N,No),h(t,it,d),h(t,U,d),U.innerHTML=pn,h(t,at,d),h(t,oe,d),e(oe,Uo),h(t,rt,d),h(t,se,d),e(se,Wo),h(t,ct,d),h(t,ne,d),e(ne,Mo),h(t,dt,d),h(t,f,d),e(f,W),e(W,Oo),e(W,M),e(M,Fo),e(W,zo),e(f,Bo),e(f,O),e(O,Vo),e(O,F),e(F,jo),e(O,Go),e(f,Jo),e(f,z),e(z,Ko),e(z,B),e(B,Qo),e(z,Zo),e(f,Xo),e(f,We),e(We,V),e(V,Yo),e(f,$o),e(f,Me),e(Me,j),e(j,es),e(f,ts),e(f,Oe),e(Oe,G),e(G,os),e(f,ss),e(f,Fe),e(Fe,J),e(J,ns),e(f,ls),e(f,ze),e(ze,K),e(K,is),e(f,as),e(f,Be),e(Be,Q),e(Q,rs)},p:ds,i:ds,o:ds,d(t){t&&o(y),t&&o(Ve),t&&o(E),t&&o(je),t&&o(Z),t&&o(Ge),t&&o(_),t&&o(Je),t&&o(q),t&&o(Ke),t&&o(X),t&&o(Qe),t&&o(H),t&&o(Ze),t&&o(T),t&&o(Xe),t&&o(R),t&&o(Ye),t&&o(g),t&&o($e),t&&o($),t&&o(et),t&&o(ee),t&&o(tt),t&&o(I),t&&o(ot),t&&o(D),t&&o(st),t&&o(m),t&&o(nt),t&&o(te),t&&o(lt),t&&o(p),t&&o(it),t&&o(U),t&&o(at),t&&o(oe),t&&o(rt),t&&o(se),t&&o(ct),t&&o(ne),t&&o(dt),t&&o(f)}}}const Sn={title:"Weekly learning review - Long polling, server sent events, web sockets",date:"2024-09-15T21:15:00.000Z"};class Pn extends kn{constructor(y){super(),yn(this,y,null,In,Tn,{})}}export{Pn as default,Sn as metadata};
