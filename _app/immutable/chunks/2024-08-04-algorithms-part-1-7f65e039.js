import{S as ei,i as ti,s as ri,e as a,t as s,a as n,c as o,b as i,d as l,f as r,g as h,k as Yo,h as d,j as e,n as ja}from"./index-794e8e40.js";function ai($o){let L,Tt,tt,v,oe,Pt,Ot,ie,Ut,At,se,Nt,jt,le,Qt,Ct,ne,Dt,rt,N,Ft,at,j,Ht,ot,w,he,Wt,Gt,ue,Mt,Rt,de,zt,Bt,me,Jt,it,Q,Zt,st,f,x,Kt,ce,Vt,Xt,Yt,fe,$t,er,I,tr,pe,rr,ar,ve,or,ir,sr,C,ge,lr,nr,hr,D,ye,ur,dr,mr,we,cr,lt,F,fr,nt,c,_e,pr,vr,H,be,gr,yr,wr,W,Ee,_r,br,Er,ke,kr,Ir,Ie,Lr,qr,T,Sr,Le,xr,Tr,Pr,G,Or,b,qe,Ur,Ar,Se,Nr,jr,xe,Qr,Cr,Te,Dr,ht,M,Fr,ut,R,Hr,dt,z,Wr,mt,B,Pe,Gr,ct,J,Mr,ft,Z,Oe,Rr,pt,K,zr,vt,V,Ue,Br,gt,X,Jr,yt,g,Ae,Zr,Kr,Ne,Vr,Xr,je,Yr,$r,Qe,ea,ta,Ce,ra,wt,Y,aa,_t,m,De,Fe,oa,ia,He,We,sa,la,Ge,Me,na,ha,Re,ze,ua,da,Be,Je,ma,ca,Ze,Ke,fa,pa,Ve,Xe,va,ga,P,O,ya,Ye,wa,_a,ba,$e,U,Ea,et,ka,Ia,bt,$,La,Et,ee,qa,kt,te,re,A,Sa,xa;return{c(){L=a("p"),Tt=s("Motivation for learning basic algorithms and data structures:"),tt=n(),v=a("ul"),oe=a("li"),Pt=s("To get to that ‘next’ level"),Ot=n(),ie=a("li"),Ut=s("Be able to make better technical decisions and be a better software engineer (is an array / map even correct? Nodes? Linked list? Stacks? The most optimal? Nested or flat? Performance and space time complexity is key - surely, there must be some learnings for this)"),At=n(),se=a("li"),Nt=s("Do better at technical interviews"),jt=n(),le=a("li"),Qt=s("Useful in many applications"),Ct=n(),ne=a("li"),Dt=s("Learning and growth (that I haven’t felt for a very long time… I feel like my brain’s been starved)"),rt=n(),N=a("p"),Ft=s("Currently learning from Princeton’s Algorithms course on Coursera. These will be summaries of what I’ve learned recently in the past week or so."),at=n(),j=a("h3"),Ht=s("Why algorithms are important"),ot=n(),w=a("ul"),he=a("li"),Wt=s("Empirical way to solve problems"),Gt=n(),ue=a("li"),Mt=s("Even having the most fastest supercomputer won’t solve everything if an algorithm is too slow or takes too long. This is why having a good algorithm and using the correct data structure is important."),Rt=n(),de=a("li"),zt=s("Optimal performance / space and time complexity is key."),Bt=n(),me=a("li"),Jt=s("Avoid quadratic / exponential running time, aim for constant, linear, logarithmic, or linearithmic time."),it=n(),Q=a("h3"),Zt=s("Quick find and quick union algorithms for connectivity problems"),st=n(),f=a("ul"),x=a("li"),Kt=s("Generally for a given a set of objects, see if they are connected or not, or connect them via "),ce=a("code"),Vt=s("union"),Xt=s("."),Yt=n(),fe=a("li"),$t=s("Primarily used to solve connectivity / network problems"),er=n(),I=a("li"),tr=s("Defines whether two values are "),pe=a("code"),rr=s("connected"),ar=s(", or "),ve=a("code"),or=s("union"),ir=s(" (connect) two values together"),sr=n(),C=a("li"),ge=a("strong"),lr=s("Quick find"),nr=s(" algorithm is naive and too slow (quadratic running time which is bad)"),hr=n(),D=a("li"),ye=a("strong"),ur=s("Quick union"),dr=s(" algorithm is slightly faster, but still too slow (quadratic time)"),mr=n(),we=a("li"),cr=s("Improvements proposed for quick union is to do a weighted quick union (where we attach smaller trees to larger trees), coupled with a path compression (connect nodes to closest to its parent to ‘compress’ trees and avoid having tall tree nodes) which makes it closer to linearithmic running time (for worst case)"),lt=n(),F=a("h3"),fr=s("Stacks, queues and bags (linked list and array implementations)"),nt=n(),c=a("ul"),_e=a("li"),pr=s("These are data structures used for a collection of objects needing to insert, remove, iterate or test if data structure is empty"),vr=n(),H=a("li"),be=a("strong"),gr=s("Stack"),yr=s(" (as the name suggests) takes a LIFO approach (last in, first out) - like a stack of paper, you can put things on top (push) or take remove things from the top first (pop)"),wr=n(),W=a("li"),Ee=a("strong"),_r=s("Queue"),br=s(" on the other hand takes a FIFO approach (first in, first out) - inserting at the front means to enqueue, while removing the last element means to dequeue."),Er=n(),ke=a("li"),kr=s("These can either be implemented using a linked list (via nodes - but the order of assignment matters depending on which operation is done such as pop, push, enqueue, dequeue), or an ‘dynamic sized’ array (or do ‘repeated doubling’ for languages that have fixed sized arrays to allow for dynamic capacity - e.g. when pushing an element past its fixed size)"),Ir=n(),Ie=a("li"),Lr=s("Most operations are linear (N) or constant time"),qr=n(),T=a("li"),Sr=s("A "),Le=a("strong"),xr=s("bag"),Tr=s(" is just a data structure for adding items to a collection, order does not matter (there is no removal, just insertion)"),Pr=n(),G=a("li"),Or=s("Applications of stacks and queues:"),b=a("ul"),qe=a("li"),Ur=s("Back button of a web browser"),Ar=n(),Se=a("li"),Nr=s("Undo feature on applications"),jr=n(),xe=a("li"),Qr=s("JavaScript’s call stack"),Cr=n(),Te=a("li"),Dr=s("SQS in AWS (FIFO approach)"),ht=n(),M=a("h3"),Fr=s("Sorting algorithms"),ut=n(),R=a("p"),Hr=s(`There are many different sorting algorithms.
The main ones are:`),dt=n(),z=a("h4"),Wr=s("Selection sort"),mt=n(),B=a("ul"),Pe=a("li"),Gr=s("iterate over unsorted array, and find the index of the minimum smallest remaining entry and swap the two values in-place and repeat until the end (quadratic time, regardless of whether input is sorted or not)"),ct=n(),J=a("h4"),Mr=s("Insertion sort"),ft=n(),Z=a("ul"),Oe=a("li"),Rr=s("iterate over unsorted array, and swap value with each larger entry to the ‘left’ of the array and repeat until pointer has gone from left to right (generally twice as fast as selection sort, and can depend on whether array is partially sorted or not, works better when partially sorted due to less exchanges made = less work to do, though can be quadratic time in worst case)"),pt=n(),K=a("h4"),zr=s("Shell sort"),vt=n(),V=a("ul"),Ue=a("li"),Br=s("pretty much the same as insertion sort, but instead of jumping by 1 at a time, it jumps every nth element or hth element (~3h + 1 is an example), does have some increase in performance compared to usual insertion sort"),gt=n(),X=a("h4"),Jr=s("Merge sort"),yt=n(),g=a("ul"),Ae=a("li"),Zr=s("divide array into 2 halves, recursively sort each half (subarrays) and then merge the two halves"),Kr=n(),Ne=a("li"),Vr=s("this uses an auxillary array (ie requires more space rather than sorting in-place compared to previous algorithms), but is lot more performant than the previous sorting algorithms (as it is linearithmic running time)"),Xr=n(),je=a("li"),Yr=s("recommended to use insertion sort for small subarrays, as mergesort does have some overhead (due to recursion)"),$r=n(),Qe=a("li"),ea=s("can consider ‘bottom-up’ mergesort as an improvement"),ta=n(),Ce=a("li"),ra=s("has stability (i.e. able to sort and preserve relative order - e.g. if we sort by two or more different keys (such as name and location) and had equal / duplicate keys, this is preserved) and gurarnteed performance, but uses more memory"),wt=n(),Y=a("h4"),aa=s("Quick sort"),_t=n(),m=a("ul"),De=a("li"),Fe=a("p"),oa=s("shuffle array, partition array with a partitioning element so that there are no larger entries to the left of the element, and no smaller entires to the right of the element, then sort left side, sort right side recursively then merge"),ia=n(),He=a("li"),We=a("p"),sa=s("most of this is in-place, thus no extra space required, and has better running time than mergesort"),la=n(),Ge=a("li"),Me=a("p"),na=s("shuffling is required to ensure performance guarantee as this algorithm does produce worst cases when array is partially or fully sorted"),ha=n(),Re=a("li"),ze=a("p"),ua=s("NOT stable (as partitioning requires moving items across larger distances)"),da=n(),Be=a("li"),Je=a("p"),ma=s("consider using insertion sort for smaller subarrays"),ca=n(),Ze=a("li"),Ke=a("p"),fa=s("When dealing with duplicate keys, consider a 3-way partition instead (where duplicated keys are grouped together before sorting and merging)"),pa=n(),Ve=a("li"),Xe=a("p"),va=s("uses less memory and faster, but not stable"),ga=n(),P=a("li"),O=a("p"),ya=s("Implementing a "),Ye=a("strong"),wa=s("shuffle"),_a=s(" is important in some cases to guarantee performance (as seen in quicksort)"),ba=n(),$e=a("ul"),U=a("li"),Ea=s("iterate over array and pick integer between 0 and i randomly using a uniform distribution ("),et=a("code"),ka=s("Math.random"),Ia=s(" in JS is close), then swap between the two values, and go from left to right"),bt=n(),$=a("p"),La=s(`Which one to use? Depends on your use case, but generally, quicksort and mergesort are the ones that are most widely used due to performance and being ‘generally good enough’ for most cases.
It all depends on whether we need stability, or if we have duplicate or distinct / unique keys, the numebr of items we are sorting, and how they are ordered, or whether we need to meet performance or space requirements.`),Et=n(),ee=a("h3"),qa=s("References:"),kt=n(),te=a("ul"),re=a("li"),A=a("a"),Sa=s("Algorithms, Part 1"),xa=s(" course on Coursera (modules 1-7)"),this.h()},l(t){L=o(t,"P",{});var u=i(L);Tt=l(u,"Motivation for learning basic algorithms and data structures:"),u.forEach(r),tt=h(t),v=o(t,"UL",{});var E=i(v);oe=o(E,"LI",{});var Qa=i(oe);Pt=l(Qa,"To get to that ‘next’ level"),Qa.forEach(r),Ot=h(E),ie=o(E,"LI",{});var Ca=i(ie);Ut=l(Ca,"Be able to make better technical decisions and be a better software engineer (is an array / map even correct? Nodes? Linked list? Stacks? The most optimal? Nested or flat? Performance and space time complexity is key - surely, there must be some learnings for this)"),Ca.forEach(r),At=h(E),se=o(E,"LI",{});var Da=i(se);Nt=l(Da,"Do better at technical interviews"),Da.forEach(r),jt=h(E),le=o(E,"LI",{});var Fa=i(le);Qt=l(Fa,"Useful in many applications"),Fa.forEach(r),Ct=h(E),ne=o(E,"LI",{});var Ha=i(ne);Dt=l(Ha,"Learning and growth (that I haven’t felt for a very long time… I feel like my brain’s been starved)"),Ha.forEach(r),E.forEach(r),rt=h(t),N=o(t,"P",{});var Wa=i(N);Ft=l(Wa,"Currently learning from Princeton’s Algorithms course on Coursera. These will be summaries of what I’ve learned recently in the past week or so."),Wa.forEach(r),at=h(t),j=o(t,"H3",{});var Ga=i(j);Ht=l(Ga,"Why algorithms are important"),Ga.forEach(r),ot=h(t),w=o(t,"UL",{});var q=i(w);he=o(q,"LI",{});var Ma=i(he);Wt=l(Ma,"Empirical way to solve problems"),Ma.forEach(r),Gt=h(q),ue=o(q,"LI",{});var Ra=i(ue);Mt=l(Ra,"Even having the most fastest supercomputer won’t solve everything if an algorithm is too slow or takes too long. This is why having a good algorithm and using the correct data structure is important."),Ra.forEach(r),Rt=h(q),de=o(q,"LI",{});var za=i(de);zt=l(za,"Optimal performance / space and time complexity is key."),za.forEach(r),Bt=h(q),me=o(q,"LI",{});var Ba=i(me);Jt=l(Ba,"Avoid quadratic / exponential running time, aim for constant, linear, logarithmic, or linearithmic time."),Ba.forEach(r),q.forEach(r),it=h(t),Q=o(t,"H3",{});var Ja=i(Q);Zt=l(Ja,"Quick find and quick union algorithms for connectivity problems"),Ja.forEach(r),st=h(t),f=o(t,"UL",{});var _=i(f);x=o(_,"LI",{});var It=i(x);Kt=l(It,"Generally for a given a set of objects, see if they are connected or not, or connect them via "),ce=o(It,"CODE",{});var Za=i(ce);Vt=l(Za,"union"),Za.forEach(r),Xt=l(It,"."),It.forEach(r),Yt=h(_),fe=o(_,"LI",{});var Ka=i(fe);$t=l(Ka,"Primarily used to solve connectivity / network problems"),Ka.forEach(r),er=h(_),I=o(_,"LI",{});var ae=i(I);tr=l(ae,"Defines whether two values are "),pe=o(ae,"CODE",{});var Va=i(pe);rr=l(Va,"connected"),Va.forEach(r),ar=l(ae,", or "),ve=o(ae,"CODE",{});var Xa=i(ve);or=l(Xa,"union"),Xa.forEach(r),ir=l(ae," (connect) two values together"),ae.forEach(r),sr=h(_),C=o(_,"LI",{});var Ta=i(C);ge=o(Ta,"STRONG",{});var Ya=i(ge);lr=l(Ya,"Quick find"),Ya.forEach(r),nr=l(Ta," algorithm is naive and too slow (quadratic running time which is bad)"),Ta.forEach(r),hr=h(_),D=o(_,"LI",{});var Pa=i(D);ye=o(Pa,"STRONG",{});var $a=i(ye);ur=l($a,"Quick union"),$a.forEach(r),dr=l(Pa," algorithm is slightly faster, but still too slow (quadratic time)"),Pa.forEach(r),mr=h(_),we=o(_,"LI",{});var eo=i(we);cr=l(eo,"Improvements proposed for quick union is to do a weighted quick union (where we attach smaller trees to larger trees), coupled with a path compression (connect nodes to closest to its parent to ‘compress’ trees and avoid having tall tree nodes) which makes it closer to linearithmic running time (for worst case)"),eo.forEach(r),_.forEach(r),lt=h(t),F=o(t,"H3",{});var to=i(F);fr=l(to,"Stacks, queues and bags (linked list and array implementations)"),to.forEach(r),nt=h(t),c=o(t,"UL",{});var y=i(c);_e=o(y,"LI",{});var ro=i(_e);pr=l(ro,"These are data structures used for a collection of objects needing to insert, remove, iterate or test if data structure is empty"),ro.forEach(r),vr=h(y),H=o(y,"LI",{});var Oa=i(H);be=o(Oa,"STRONG",{});var ao=i(be);gr=l(ao,"Stack"),ao.forEach(r),yr=l(Oa," (as the name suggests) takes a LIFO approach (last in, first out) - like a stack of paper, you can put things on top (push) or take remove things from the top first (pop)"),Oa.forEach(r),wr=h(y),W=o(y,"LI",{});var Ua=i(W);Ee=o(Ua,"STRONG",{});var oo=i(Ee);_r=l(oo,"Queue"),oo.forEach(r),br=l(Ua," on the other hand takes a FIFO approach (first in, first out) - inserting at the front means to enqueue, while removing the last element means to dequeue."),Ua.forEach(r),Er=h(y),ke=o(y,"LI",{});var io=i(ke);kr=l(io,"These can either be implemented using a linked list (via nodes - but the order of assignment matters depending on which operation is done such as pop, push, enqueue, dequeue), or an ‘dynamic sized’ array (or do ‘repeated doubling’ for languages that have fixed sized arrays to allow for dynamic capacity - e.g. when pushing an element past its fixed size)"),io.forEach(r),Ir=h(y),Ie=o(y,"LI",{});var so=i(Ie);Lr=l(so,"Most operations are linear (N) or constant time"),so.forEach(r),qr=h(y),T=o(y,"LI",{});var Lt=i(T);Sr=l(Lt,"A "),Le=o(Lt,"STRONG",{});var lo=i(Le);xr=l(lo,"bag"),lo.forEach(r),Tr=l(Lt," is just a data structure for adding items to a collection, order does not matter (there is no removal, just insertion)"),Lt.forEach(r),Pr=h(y),G=o(y,"LI",{});var Aa=i(G);Or=l(Aa,"Applications of stacks and queues:"),b=o(Aa,"UL",{});var S=i(b);qe=o(S,"LI",{});var no=i(qe);Ur=l(no,"Back button of a web browser"),no.forEach(r),Ar=h(S),Se=o(S,"LI",{});var ho=i(Se);Nr=l(ho,"Undo feature on applications"),ho.forEach(r),jr=h(S),xe=o(S,"LI",{});var uo=i(xe);Qr=l(uo,"JavaScript’s call stack"),uo.forEach(r),Cr=h(S),Te=o(S,"LI",{});var mo=i(Te);Dr=l(mo,"SQS in AWS (FIFO approach)"),mo.forEach(r),S.forEach(r),Aa.forEach(r),y.forEach(r),ht=h(t),M=o(t,"H3",{});var co=i(M);Fr=l(co,"Sorting algorithms"),co.forEach(r),ut=h(t),R=o(t,"P",{});var fo=i(R);Hr=l(fo,`There are many different sorting algorithms.
The main ones are:`),fo.forEach(r),dt=h(t),z=o(t,"H4",{});var po=i(z);Wr=l(po,"Selection sort"),po.forEach(r),mt=h(t),B=o(t,"UL",{});var vo=i(B);Pe=o(vo,"LI",{});var go=i(Pe);Gr=l(go,"iterate over unsorted array, and find the index of the minimum smallest remaining entry and swap the two values in-place and repeat until the end (quadratic time, regardless of whether input is sorted or not)"),go.forEach(r),vo.forEach(r),ct=h(t),J=o(t,"H4",{});var yo=i(J);Mr=l(yo,"Insertion sort"),yo.forEach(r),ft=h(t),Z=o(t,"UL",{});var wo=i(Z);Oe=o(wo,"LI",{});var _o=i(Oe);Rr=l(_o,"iterate over unsorted array, and swap value with each larger entry to the ‘left’ of the array and repeat until pointer has gone from left to right (generally twice as fast as selection sort, and can depend on whether array is partially sorted or not, works better when partially sorted due to less exchanges made = less work to do, though can be quadratic time in worst case)"),_o.forEach(r),wo.forEach(r),pt=h(t),K=o(t,"H4",{});var bo=i(K);zr=l(bo,"Shell sort"),bo.forEach(r),vt=h(t),V=o(t,"UL",{});var Eo=i(V);Ue=o(Eo,"LI",{});var ko=i(Ue);Br=l(ko,"pretty much the same as insertion sort, but instead of jumping by 1 at a time, it jumps every nth element or hth element (~3h + 1 is an example), does have some increase in performance compared to usual insertion sort"),ko.forEach(r),Eo.forEach(r),gt=h(t),X=o(t,"H4",{});var Io=i(X);Jr=l(Io,"Merge sort"),Io.forEach(r),yt=h(t),g=o(t,"UL",{});var k=i(g);Ae=o(k,"LI",{});var Lo=i(Ae);Zr=l(Lo,"divide array into 2 halves, recursively sort each half (subarrays) and then merge the two halves"),Lo.forEach(r),Kr=h(k),Ne=o(k,"LI",{});var qo=i(Ne);Vr=l(qo,"this uses an auxillary array (ie requires more space rather than sorting in-place compared to previous algorithms), but is lot more performant than the previous sorting algorithms (as it is linearithmic running time)"),qo.forEach(r),Xr=h(k),je=o(k,"LI",{});var So=i(je);Yr=l(So,"recommended to use insertion sort for small subarrays, as mergesort does have some overhead (due to recursion)"),So.forEach(r),$r=h(k),Qe=o(k,"LI",{});var xo=i(Qe);ea=l(xo,"can consider ‘bottom-up’ mergesort as an improvement"),xo.forEach(r),ta=h(k),Ce=o(k,"LI",{});var To=i(Ce);ra=l(To,"has stability (i.e. able to sort and preserve relative order - e.g. if we sort by two or more different keys (such as name and location) and had equal / duplicate keys, this is preserved) and gurarnteed performance, but uses more memory"),To.forEach(r),k.forEach(r),wt=h(t),Y=o(t,"H4",{});var Po=i(Y);aa=l(Po,"Quick sort"),Po.forEach(r),_t=h(t),m=o(t,"UL",{});var p=i(m);De=o(p,"LI",{});var Oo=i(De);Fe=o(Oo,"P",{});var Uo=i(Fe);oa=l(Uo,"shuffle array, partition array with a partitioning element so that there are no larger entries to the left of the element, and no smaller entires to the right of the element, then sort left side, sort right side recursively then merge"),Uo.forEach(r),Oo.forEach(r),ia=h(p),He=o(p,"LI",{});var Ao=i(He);We=o(Ao,"P",{});var No=i(We);sa=l(No,"most of this is in-place, thus no extra space required, and has better running time than mergesort"),No.forEach(r),Ao.forEach(r),la=h(p),Ge=o(p,"LI",{});var jo=i(Ge);Me=o(jo,"P",{});var Qo=i(Me);na=l(Qo,"shuffling is required to ensure performance guarantee as this algorithm does produce worst cases when array is partially or fully sorted"),Qo.forEach(r),jo.forEach(r),ha=h(p),Re=o(p,"LI",{});var Co=i(Re);ze=o(Co,"P",{});var Do=i(ze);ua=l(Do,"NOT stable (as partitioning requires moving items across larger distances)"),Do.forEach(r),Co.forEach(r),da=h(p),Be=o(p,"LI",{});var Fo=i(Be);Je=o(Fo,"P",{});var Ho=i(Je);ma=l(Ho,"consider using insertion sort for smaller subarrays"),Ho.forEach(r),Fo.forEach(r),ca=h(p),Ze=o(p,"LI",{});var Wo=i(Ze);Ke=o(Wo,"P",{});var Go=i(Ke);fa=l(Go,"When dealing with duplicate keys, consider a 3-way partition instead (where duplicated keys are grouped together before sorting and merging)"),Go.forEach(r),Wo.forEach(r),pa=h(p),Ve=o(p,"LI",{});var Mo=i(Ve);Xe=o(Mo,"P",{});var Ro=i(Xe);va=l(Ro,"uses less memory and faster, but not stable"),Ro.forEach(r),Mo.forEach(r),ga=h(p),P=o(p,"LI",{});var qt=i(P);O=o(qt,"P",{});var St=i(O);ya=l(St,"Implementing a "),Ye=o(St,"STRONG",{});var zo=i(Ye);wa=l(zo,"shuffle"),zo.forEach(r),_a=l(St," is important in some cases to guarantee performance (as seen in quicksort)"),St.forEach(r),ba=h(qt),$e=o(qt,"UL",{});var Bo=i($e);U=o(Bo,"LI",{});var xt=i(U);Ea=l(xt,"iterate over array and pick integer between 0 and i randomly using a uniform distribution ("),et=o(xt,"CODE",{});var Jo=i(et);ka=l(Jo,"Math.random"),Jo.forEach(r),Ia=l(xt," in JS is close), then swap between the two values, and go from left to right"),xt.forEach(r),Bo.forEach(r),qt.forEach(r),p.forEach(r),bt=h(t),$=o(t,"P",{});var Zo=i($);La=l(Zo,`Which one to use? Depends on your use case, but generally, quicksort and mergesort are the ones that are most widely used due to performance and being ‘generally good enough’ for most cases.
It all depends on whether we need stability, or if we have duplicate or distinct / unique keys, the numebr of items we are sorting, and how they are ordered, or whether we need to meet performance or space requirements.`),Zo.forEach(r),Et=h(t),ee=o(t,"H3",{});var Ko=i(ee);qa=l(Ko,"References:"),Ko.forEach(r),kt=h(t),te=o(t,"UL",{});var Vo=i(te);re=o(Vo,"LI",{});var Na=i(re);A=o(Na,"A",{href:!0,rel:!0});var Xo=i(A);Sa=l(Xo,"Algorithms, Part 1"),Xo.forEach(r),xa=l(Na," course on Coursera (modules 1-7)"),Na.forEach(r),Vo.forEach(r),this.h()},h(){Yo(A,"href","https://www.coursera.org/learn/algorithms-part1"),Yo(A,"rel","nofollow")},m(t,u){d(t,L,u),e(L,Tt),d(t,tt,u),d(t,v,u),e(v,oe),e(oe,Pt),e(v,Ot),e(v,ie),e(ie,Ut),e(v,At),e(v,se),e(se,Nt),e(v,jt),e(v,le),e(le,Qt),e(v,Ct),e(v,ne),e(ne,Dt),d(t,rt,u),d(t,N,u),e(N,Ft),d(t,at,u),d(t,j,u),e(j,Ht),d(t,ot,u),d(t,w,u),e(w,he),e(he,Wt),e(w,Gt),e(w,ue),e(ue,Mt),e(w,Rt),e(w,de),e(de,zt),e(w,Bt),e(w,me),e(me,Jt),d(t,it,u),d(t,Q,u),e(Q,Zt),d(t,st,u),d(t,f,u),e(f,x),e(x,Kt),e(x,ce),e(ce,Vt),e(x,Xt),e(f,Yt),e(f,fe),e(fe,$t),e(f,er),e(f,I),e(I,tr),e(I,pe),e(pe,rr),e(I,ar),e(I,ve),e(ve,or),e(I,ir),e(f,sr),e(f,C),e(C,ge),e(ge,lr),e(C,nr),e(f,hr),e(f,D),e(D,ye),e(ye,ur),e(D,dr),e(f,mr),e(f,we),e(we,cr),d(t,lt,u),d(t,F,u),e(F,fr),d(t,nt,u),d(t,c,u),e(c,_e),e(_e,pr),e(c,vr),e(c,H),e(H,be),e(be,gr),e(H,yr),e(c,wr),e(c,W),e(W,Ee),e(Ee,_r),e(W,br),e(c,Er),e(c,ke),e(ke,kr),e(c,Ir),e(c,Ie),e(Ie,Lr),e(c,qr),e(c,T),e(T,Sr),e(T,Le),e(Le,xr),e(T,Tr),e(c,Pr),e(c,G),e(G,Or),e(G,b),e(b,qe),e(qe,Ur),e(b,Ar),e(b,Se),e(Se,Nr),e(b,jr),e(b,xe),e(xe,Qr),e(b,Cr),e(b,Te),e(Te,Dr),d(t,ht,u),d(t,M,u),e(M,Fr),d(t,ut,u),d(t,R,u),e(R,Hr),d(t,dt,u),d(t,z,u),e(z,Wr),d(t,mt,u),d(t,B,u),e(B,Pe),e(Pe,Gr),d(t,ct,u),d(t,J,u),e(J,Mr),d(t,ft,u),d(t,Z,u),e(Z,Oe),e(Oe,Rr),d(t,pt,u),d(t,K,u),e(K,zr),d(t,vt,u),d(t,V,u),e(V,Ue),e(Ue,Br),d(t,gt,u),d(t,X,u),e(X,Jr),d(t,yt,u),d(t,g,u),e(g,Ae),e(Ae,Zr),e(g,Kr),e(g,Ne),e(Ne,Vr),e(g,Xr),e(g,je),e(je,Yr),e(g,$r),e(g,Qe),e(Qe,ea),e(g,ta),e(g,Ce),e(Ce,ra),d(t,wt,u),d(t,Y,u),e(Y,aa),d(t,_t,u),d(t,m,u),e(m,De),e(De,Fe),e(Fe,oa),e(m,ia),e(m,He),e(He,We),e(We,sa),e(m,la),e(m,Ge),e(Ge,Me),e(Me,na),e(m,ha),e(m,Re),e(Re,ze),e(ze,ua),e(m,da),e(m,Be),e(Be,Je),e(Je,ma),e(m,ca),e(m,Ze),e(Ze,Ke),e(Ke,fa),e(m,pa),e(m,Ve),e(Ve,Xe),e(Xe,va),e(m,ga),e(m,P),e(P,O),e(O,ya),e(O,Ye),e(Ye,wa),e(O,_a),e(P,ba),e(P,$e),e($e,U),e(U,Ea),e(U,et),e(et,ka),e(U,Ia),d(t,bt,u),d(t,$,u),e($,La),d(t,Et,u),d(t,ee,u),e(ee,qa),d(t,kt,u),d(t,te,u),e(te,re),e(re,A),e(A,Sa),e(re,xa)},p:ja,i:ja,o:ja,d(t){t&&r(L),t&&r(tt),t&&r(v),t&&r(rt),t&&r(N),t&&r(at),t&&r(j),t&&r(ot),t&&r(w),t&&r(it),t&&r(Q),t&&r(st),t&&r(f),t&&r(lt),t&&r(F),t&&r(nt),t&&r(c),t&&r(ht),t&&r(M),t&&r(ut),t&&r(R),t&&r(dt),t&&r(z),t&&r(mt),t&&r(B),t&&r(ct),t&&r(J),t&&r(ft),t&&r(Z),t&&r(pt),t&&r(K),t&&r(vt),t&&r(V),t&&r(gt),t&&r(X),t&&r(yt),t&&r(g),t&&r(wt),t&&r(Y),t&&r(_t),t&&r(m),t&&r(bt),t&&r($),t&&r(Et),t&&r(ee),t&&r(kt),t&&r(te)}}}const ii={title:"Weekly learning review - Algorithms: Part I - 1",date:"2024-08-04T23:30:08.000Z"};class si extends ei{constructor(L){super(),ti(this,L,null,ai,ri,{})}}export{si as default,ii as metadata};
