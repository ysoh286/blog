import{S as Fi,i as Zi,s as Ji,e as o,t as a,a as n,c as i,b as s,d as r,f as t,g as h,k as sl,h as c,j as e,n as bo}from"./index-794e8e40.js";function Ki(Wi){let T,nl,ge,hl,dl,At,X,cl,Nt,m,we,fl,ul,_e,ml,pl,ye,vl,bl,ke,El,gl,Le,wl,_l,Ie,yl,Dt,Y,kl,Bt,$,ee,Ll,L,qe,Il,ql,Te,Tl,Cl,Ce,Sl,Ol,Se,xl,Ht,te,Al,Rt,E,Oe,Nl,Dl,xe,Bl,Hl,Ae,Rl,Ul,N,Pl,Ne,Ml,jl,De,Gl,zl,Wl,Be,Fl,Ut,le,Zl,Pt,g,M,Jl,He,Kl,Ql,Vl,j,Xl,Re,Yl,$l,ea,Ue,ta,la,Pe,aa,ra,Me,oa,Mt,ae,ia,jt,C,je,sa,na,Ge,ha,da,ze,ca,Gt,re,fa,zt,w,We,ua,ma,I,pa,Fe,va,ba,Ze,Ea,ga,Je,wa,_a,ya,Ke,ka,La,D,Ia,Qe,qa,Ta,Ve,Ca,Sa,Oa,oe,xa,b,Xe,Aa,Na,Ye,Da,Ba,$e,Ha,Ra,et,Ua,Pa,tt,Ma,ja,lt,Ga,Wt,ie,za,Ft,_,at,Wa,Fa,B,rt,Za,Ja,ot,Ka,Qa,it,Va,Xa,st,Ya,$a,nt,er,tr,se,lr,G,ne,ar,ht,rr,or,he,ir,dt,z,sr,ct,nr,hr,Zt,de,dr,Jt,f,ft,cr,fr,W,ut,ur,mr,F,mt,pr,vr,pt,br,Er,vt,gr,wr,bt,_r,yr,ce,kr,Et,Lr,Ir,gt,qr,Tr,Z,wt,Cr,Sr,q,_t,Or,xr,u,Ar,yt,Nr,Dr,kt,Br,Hr,Lt,Rr,Ur,It,Pr,Mr,qt,jr,Gr,Tt,zr,Wr,Ct,Fr,Zr,Jr,St,Kr,Qr,J,Vr,Ot,Xr,Yr,$r,xt,eo,Kt,fe,to,Qt,ue,lo,Vt,H,me,K,ao,ro,oo,Q,io,V,so,no;return{c(){T=o("p"),nl=a("This past week’s a continuation of going through "),ge=o("strong"),hl=a("Algorithms: Part 1"),dl=a(" course on Coursera."),At=n(),X=o("p"),cl=a("Topics covered this week:"),Nt=n(),m=o("ul"),we=o("li"),fl=a("priority queues"),ul=n(),_e=o("li"),ml=a("binary heaps"),pl=n(),ye=o("li"),vl=a("heapsort"),bl=n(),ke=o("li"),El=a("symbol tables"),gl=n(),Le=o("li"),wl=a("binary search and binary search trees (BSTs)"),_l=n(),Ie=o("li"),yl=a("2-3 search trees, red-black BSTs"),Dt=n(),Y=o("p"),kl=a("Other things:"),Bt=n(),$=o("ul"),ee=o("li"),Ll=a("Learning python through FreeCodeCamp"),L=o("ul"),qe=o("li"),Il=a("completing the arithmetic arranger"),ql=n(),Te=o("li"),Tl=a("Password generator"),Cl=n(),Ce=o("li"),Sl=a("Dijkstra’s shortest path algorithm"),Ol=n(),Se=o("li"),xl=a("Tower of Hanoi"),Ht=n(),te=o("h3"),Al=a("Priority queues"),Rt=n(),E=o("ul"),Oe=o("li"),Nl=a("Priorities queues are a queue / data structure that allows us to search, insert and remove the largest (or smallest) item in the queue."),Dl=n(),xe=o("li"),Bl=a("Usually allows us to find the largest x items in a stream of N items (examples include fraud detection to detect large suspicious transactions, file maintenance of large files in directories)"),Hl=n(),Ae=o("li"),Rl=a("Can be implemented via a linked list or an dynamic sized array"),Ul=n(),N=o("li"),Pl=a("has an extra "),Ne=o("code"),Ml=a("deleteMax() / deleteMin()"),jl=a(" function, which takes at most "),De=o("code"),Gl=a("log N"),zl=a(" time for an ordered array"),Wl=n(),Be=o("li"),Fl=a("Applications include event driven simulation, modelling particle collision in physics"),Ut=n(),le=o("h3"),Zl=a("Binary heaps"),Pt=n(),g=o("ul"),M=o("li"),Jl=a("A "),He=o("strong"),Kl=a("binary tree"),Ql=a(" is a node with links left or right to the tree (or pretty much a node with 2 links), and a complete tree is a balanced tree except for the bottom level"),Vl=n(),j=o("li"),Xl=a("A "),Re=o("strong"),Yl=a("binary heap"),$l=a(" is an array representation of a binary tree (keys are represented as nodes), keys are moved around such that parents should always be larger than children (known as a “swim” / promotion or a “sink” / demotion)"),ea=n(),Ue=o("li"),ta=a("swim = going up the heap / tree (promotion)"),la=n(),Pe=o("li"),aa=a("sink = going down the heap / tree (demotion)"),ra=n(),Me=o("li"),oa=a("Common operations include insertion, deletion (deleting maximum) - to assist sink, swim operations are added"),Mt=n(),ae=o("h3"),ia=a("Heapsort"),jt=n(),C=o("ul"),je=o("li"),sa=a("A heapsort is an in-place sort that takes the largest value of the tree and swaps it where it should be, and then removes that node to put it at the end. This requires a sink to ‘demote’ the swapped value in order to achieve heap principles (which is that the top / root / parent should always have the largest value)"),na=n(),Ge=o("li"),ha=a("in-place algorithm which sorts with N log N running time as the worst case, in comparison to mergesort that requires extra space, and quick sort which has quadratic time as the worst case possible if not shuffled"),da=n(),ze=o("li"),ca=a("Although theoretically it is optimal, it’s not used often as it generally does take longer than quicksort in some practical cases, is unstable and is not memory efficient."),Gt=n(),re=o("h3"),fa=a("Symbol table"),zt=n(),w=o("ul"),We=o("li"),ua=a("A symbol table is a key-value pair abstraction that allows insertion of a value for a given / specified key, or search for a value given a key"),ma=n(),I=o("li"),pa=a("Has "),Fe=o("code"),va=a("get()"),ba=a(" , "),Ze=o("code"),Ea=a("put()"),ga=a(" , "),Je=o("code"),wa=a("delete()"),_a=a(" utilities"),ya=n(),Ke=o("li"),ka=a("A sequential search for an unordered list would include searching through all elements until we find a match, and inserting would also do the same, modify if match found otherwise insert at the end - this is not efficient as it takes N time for both operations."),La=n(),D=o("li"),Ia=a("A "),Qe=o("strong"),qa=a("binary search"),Ta=a(" requires an ordered list and searches better than a sequential search, where it can take "),Ve=o("code"),Ca=a("log N"),Sa=a(" for searching for both worst and average cases."),Oa=n(),oe=o("li"),xa=a("In the case for ordered lists or algorithms that perform better when things are ordered - there are more operations to account for:"),b=o("ul"),Xe=o("li"),Aa=a("insert / deletes"),Na=n(),Ye=o("li"),Da=a("min / max"),Ba=n(),$e=o("li"),Ha=a("floor / ceiling"),Ra=n(),et=o("li"),Ua=a("rank"),Pa=n(),tt=o("li"),Ma=a("select"),ja=n(),lt=o("li"),Ga=a("search"),Wt=n(),ie=o("h3"),za=a("Binary search tree"),Ft=n(),_=o("ul"),at=o("li"),Wa=a("A binary search tree is a tree that is in symmetric order and has 2 disjointed binary trees left and right, where each node has a key and is larger that all keys in its left subtree, and smaller than all keys in its right subtree"),Fa=n(),B=o("li"),rt=o("code"),Za=a("left"),Ja=a(" and "),ot=o("code"),Ka=a("right"),Qa=a(" nodes are tracked in each "),it=o("code"),Va=a("node"),Xa=n(),st=o("li"),Ya=a("algorithm for insertion / search requires recursion (for search - if less go left, else go right until the end, while for insertion - if less go left, else go right. If value is null, insert or end search)"),$a=n(),nt=o("li"),er=a("Logarithmic time (~2 ln N) for insertion and search for the average case."),tr=n(),se=o("li"),lr=a("Deleting a node in a binary search tree isn’t so simple"),G=o("ul"),ne=o("li"),ar=a("‘tombstone’ method / lazy delete - where it’s not really deleted, and node is just updated to "),ht=o("code"),rr=a("null"),or=n(),he=o("li"),ir=a("Hibbard deletion is considered (where we swap the node to be deleted with its successor), but has flaws as it makes the tree asymmetric and unbalanced, which presents problems and we should NOT have a dynamic changes"),dt=o("ul"),z=o("li"),sr=a("When tree is no longer balanced and random, then operations for the worst case will take "),ct=o("code"),nr=a("sqrt(N)"),hr=a(" which is worse than the balanced binary search tree. Thus, we need a better algorithm to guarantee better and optimal performance (this is found in the red-black BST)"),Zt=n(),de=o("h3"),dr=a("Red-black BSTs"),Jt=n(),f=o("ul"),ft=o("li"),cr=a("A way to guarantee logarithmic performance for binary search trees"),fr=n(),W=o("li"),ut=o("strong"),ur=a("2-3 trees"),mr=a(" are 2-node or 3-node trees"),F=o("ul"),mt=o("li"),pr=a("2 node = 1 key with 2 children"),vr=n(),pt=o("li"),br=a("3 node = 2 keys, 3 children"),Er=n(),vt=o("li"),gr=a("Must be perfectly balanced and symmetric"),wr=n(),bt=o("li"),_r=a("If a 4-node occurs, this must be ‘promoted’ and split into 2 nodes"),yr=n(),ce=o("li"),kr=a("2-3 trees has transformations to maintain this symmetric order and balance where operations are guaranteed logarithmic run time "),Et=o("code"),Lr=a("c log N"),Ir=n(),gt=o("li"),qr=a("However, the implementation for 2-3 trees is complex, thus we consider red-black BSTs instead"),Tr=n(),Z=o("li"),wt=o("strong"),Cr=a("Red black BST"),Sr=a(": BST that has no 2 red links connected to it, every path from root to link has the same number of black links, and red links all lean left (“internal” left leaning links act as “glue” for 3 nodes)"),q=o("ul"),_t=o("li"),Or=a("all operations are pretty much the same implementation as a BST with the exception of insertion to achieve balance"),xr=n(),u=o("li"),Ar=a("Utilities to help include identifying whether a node is "),yt=o("code"),Nr=a("red"),Dr=a(" link, or a "),kt=o("code"),Br=a("black"),Hr=a(" link, or whether a "),Lt=o("code"),Rr=a("leftRotation"),Ur=a(" or "),It=o("code"),Pr=a("rightRotation"),Mr=a(" is required (these are required as red-black BSTs are required to be left leaning, "),qt=o("code"),jr=a("rightRotation"),Gr=a(" is generally temporary state to achieve left leaning later), or to flip colours of a link (turn a "),Tt=o("code"),zr=a("red"),Wr=a(" link to "),Ct=o("code"),Fr=a("black"),Zr=a(" link after rotation if applicable for a temporary 4-node being split into 2-nodes)"),Jr=n(),St=o("li"),Kr=a("Recursion makes this algorithm straightforward to implement (but complex to understand) and covers several edge cases. If we had to impelment this without recursion, it would be difficult due to the number of edge cases to be considered."),Qr=n(),J=o("li"),Vr=a("Height of a red-black BST is at most less than or equal to "),Ot=o("code"),Xr=a("2 log N"),Yr=a(", and thus the operations (including deletion via Hibbard’s deletion) would take at most logarithmic running time."),$r=n(),xt=o("li"),eo=a("Applications include file system model in operating systems and databases, treemap / treeset utilities, stack scanning"),Kt=n(),fe=o("p"),to=a("Should hope to wrap up the lectures from this course and dive deep into implementing these from scratch soon."),Qt=n(),ue=o("h3"),lo=a("References"),Vt=n(),H=o("ul"),me=o("li"),K=o("a"),ao=a("Algorithms, Part 1"),ro=a(" course on Coursera (modules 8-10)"),oo=n(),Q=o("li"),io=a("More about "),V=o("a"),so=a("Hibbard Deletion"),no=a(" - Oxford College CS171"),this.h()},l(l){T=i(l,"P",{});var d=s(T);nl=r(d,"This past week’s a continuation of going through "),ge=i(d,"STRONG",{});var Eo=s(ge);hl=r(Eo,"Algorithms: Part 1"),Eo.forEach(t),dl=r(d," course on Coursera."),d.forEach(t),At=h(l),X=i(l,"P",{});var go=s(X);cl=r(go,"Topics covered this week:"),go.forEach(t),Nt=h(l),m=i(l,"UL",{});var y=s(m);we=i(y,"LI",{});var wo=s(we);fl=r(wo,"priority queues"),wo.forEach(t),ul=h(y),_e=i(y,"LI",{});var _o=s(_e);ml=r(_o,"binary heaps"),_o.forEach(t),pl=h(y),ye=i(y,"LI",{});var yo=s(ye);vl=r(yo,"heapsort"),yo.forEach(t),bl=h(y),ke=i(y,"LI",{});var ko=s(ke);El=r(ko,"symbol tables"),ko.forEach(t),gl=h(y),Le=i(y,"LI",{});var Lo=s(Le);wl=r(Lo,"binary search and binary search trees (BSTs)"),Lo.forEach(t),_l=h(y),Ie=i(y,"LI",{});var Io=s(Ie);yl=r(Io,"2-3 search trees, red-black BSTs"),Io.forEach(t),y.forEach(t),Dt=h(l),Y=i(l,"P",{});var qo=s(Y);kl=r(qo,"Other things:"),qo.forEach(t),Bt=h(l),$=i(l,"UL",{});var To=s($);ee=i(To,"LI",{});var ho=s(ee);Ll=r(ho,"Learning python through FreeCodeCamp"),L=i(ho,"UL",{});var R=s(L);qe=i(R,"LI",{});var Co=s(qe);Il=r(Co,"completing the arithmetic arranger"),Co.forEach(t),ql=h(R),Te=i(R,"LI",{});var So=s(Te);Tl=r(So,"Password generator"),So.forEach(t),Cl=h(R),Ce=i(R,"LI",{});var Oo=s(Ce);Sl=r(Oo,"Dijkstra’s shortest path algorithm"),Oo.forEach(t),Ol=h(R),Se=i(R,"LI",{});var xo=s(Se);xl=r(xo,"Tower of Hanoi"),xo.forEach(t),R.forEach(t),ho.forEach(t),To.forEach(t),Ht=h(l),te=i(l,"H3",{});var Ao=s(te);Al=r(Ao,"Priority queues"),Ao.forEach(t),Rt=h(l),E=i(l,"UL",{});var S=s(E);Oe=i(S,"LI",{});var No=s(Oe);Nl=r(No,"Priorities queues are a queue / data structure that allows us to search, insert and remove the largest (or smallest) item in the queue."),No.forEach(t),Dl=h(S),xe=i(S,"LI",{});var Do=s(xe);Bl=r(Do,"Usually allows us to find the largest x items in a stream of N items (examples include fraud detection to detect large suspicious transactions, file maintenance of large files in directories)"),Do.forEach(t),Hl=h(S),Ae=i(S,"LI",{});var Bo=s(Ae);Rl=r(Bo,"Can be implemented via a linked list or an dynamic sized array"),Bo.forEach(t),Ul=h(S),N=i(S,"LI",{});var pe=s(N);Pl=r(pe,"has an extra "),Ne=i(pe,"CODE",{});var Ho=s(Ne);Ml=r(Ho,"deleteMax() / deleteMin()"),Ho.forEach(t),jl=r(pe," function, which takes at most "),De=i(pe,"CODE",{});var Ro=s(De);Gl=r(Ro,"log N"),Ro.forEach(t),zl=r(pe," time for an ordered array"),pe.forEach(t),Wl=h(S),Be=i(S,"LI",{});var Uo=s(Be);Fl=r(Uo,"Applications include event driven simulation, modelling particle collision in physics"),Uo.forEach(t),S.forEach(t),Ut=h(l),le=i(l,"H3",{});var Po=s(le);Zl=r(Po,"Binary heaps"),Po.forEach(t),Pt=h(l),g=i(l,"UL",{});var O=s(g);M=i(O,"LI",{});var Xt=s(M);Jl=r(Xt,"A "),He=i(Xt,"STRONG",{});var Mo=s(He);Kl=r(Mo,"binary tree"),Mo.forEach(t),Ql=r(Xt," is a node with links left or right to the tree (or pretty much a node with 2 links), and a complete tree is a balanced tree except for the bottom level"),Xt.forEach(t),Vl=h(O),j=i(O,"LI",{});var Yt=s(j);Xl=r(Yt,"A "),Re=i(Yt,"STRONG",{});var jo=s(Re);Yl=r(jo,"binary heap"),jo.forEach(t),$l=r(Yt," is an array representation of a binary tree (keys are represented as nodes), keys are moved around such that parents should always be larger than children (known as a “swim” / promotion or a “sink” / demotion)"),Yt.forEach(t),ea=h(O),Ue=i(O,"LI",{});var Go=s(Ue);ta=r(Go,"swim = going up the heap / tree (promotion)"),Go.forEach(t),la=h(O),Pe=i(O,"LI",{});var zo=s(Pe);aa=r(zo,"sink = going down the heap / tree (demotion)"),zo.forEach(t),ra=h(O),Me=i(O,"LI",{});var Wo=s(Me);oa=r(Wo,"Common operations include insertion, deletion (deleting maximum) - to assist sink, swim operations are added"),Wo.forEach(t),O.forEach(t),Mt=h(l),ae=i(l,"H3",{});var Fo=s(ae);ia=r(Fo,"Heapsort"),Fo.forEach(t),jt=h(l),C=i(l,"UL",{});var ve=s(C);je=i(ve,"LI",{});var Zo=s(je);sa=r(Zo,"A heapsort is an in-place sort that takes the largest value of the tree and swaps it where it should be, and then removes that node to put it at the end. This requires a sink to ‘demote’ the swapped value in order to achieve heap principles (which is that the top / root / parent should always have the largest value)"),Zo.forEach(t),na=h(ve),Ge=i(ve,"LI",{});var Jo=s(Ge);ha=r(Jo,"in-place algorithm which sorts with N log N running time as the worst case, in comparison to mergesort that requires extra space, and quick sort which has quadratic time as the worst case possible if not shuffled"),Jo.forEach(t),da=h(ve),ze=i(ve,"LI",{});var Ko=s(ze);ca=r(Ko,"Although theoretically it is optimal, it’s not used often as it generally does take longer than quicksort in some practical cases, is unstable and is not memory efficient."),Ko.forEach(t),ve.forEach(t),Gt=h(l),re=i(l,"H3",{});var Qo=s(re);fa=r(Qo,"Symbol table"),Qo.forEach(t),zt=h(l),w=i(l,"UL",{});var x=s(w);We=i(x,"LI",{});var Vo=s(We);ua=r(Vo,"A symbol table is a key-value pair abstraction that allows insertion of a value for a given / specified key, or search for a value given a key"),Vo.forEach(t),ma=h(x),I=i(x,"LI",{});var U=s(I);pa=r(U,"Has "),Fe=i(U,"CODE",{});var Xo=s(Fe);va=r(Xo,"get()"),Xo.forEach(t),ba=r(U," , "),Ze=i(U,"CODE",{});var Yo=s(Ze);Ea=r(Yo,"put()"),Yo.forEach(t),ga=r(U," , "),Je=i(U,"CODE",{});var $o=s(Je);wa=r($o,"delete()"),$o.forEach(t),_a=r(U," utilities"),U.forEach(t),ya=h(x),Ke=i(x,"LI",{});var ei=s(Ke);ka=r(ei,"A sequential search for an unordered list would include searching through all elements until we find a match, and inserting would also do the same, modify if match found otherwise insert at the end - this is not efficient as it takes N time for both operations."),ei.forEach(t),La=h(x),D=i(x,"LI",{});var be=s(D);Ia=r(be,"A "),Qe=i(be,"STRONG",{});var ti=s(Qe);qa=r(ti,"binary search"),ti.forEach(t),Ta=r(be," requires an ordered list and searches better than a sequential search, where it can take "),Ve=i(be,"CODE",{});var li=s(Ve);Ca=r(li,"log N"),li.forEach(t),Sa=r(be," for searching for both worst and average cases."),be.forEach(t),Oa=h(x),oe=i(x,"LI",{});var co=s(oe);xa=r(co,"In the case for ordered lists or algorithms that perform better when things are ordered - there are more operations to account for:"),b=i(co,"UL",{});var k=s(b);Xe=i(k,"LI",{});var ai=s(Xe);Aa=r(ai,"insert / deletes"),ai.forEach(t),Na=h(k),Ye=i(k,"LI",{});var ri=s(Ye);Da=r(ri,"min / max"),ri.forEach(t),Ba=h(k),$e=i(k,"LI",{});var oi=s($e);Ha=r(oi,"floor / ceiling"),oi.forEach(t),Ra=h(k),et=i(k,"LI",{});var ii=s(et);Ua=r(ii,"rank"),ii.forEach(t),Pa=h(k),tt=i(k,"LI",{});var si=s(tt);Ma=r(si,"select"),si.forEach(t),ja=h(k),lt=i(k,"LI",{});var ni=s(lt);Ga=r(ni,"search"),ni.forEach(t),k.forEach(t),co.forEach(t),x.forEach(t),Wt=h(l),ie=i(l,"H3",{});var hi=s(ie);za=r(hi,"Binary search tree"),hi.forEach(t),Ft=h(l),_=i(l,"UL",{});var A=s(_);at=i(A,"LI",{});var di=s(at);Wa=r(di,"A binary search tree is a tree that is in symmetric order and has 2 disjointed binary trees left and right, where each node has a key and is larger that all keys in its left subtree, and smaller than all keys in its right subtree"),di.forEach(t),Fa=h(A),B=i(A,"LI",{});var Ee=s(B);rt=i(Ee,"CODE",{});var ci=s(rt);Za=r(ci,"left"),ci.forEach(t),Ja=r(Ee," and "),ot=i(Ee,"CODE",{});var fi=s(ot);Ka=r(fi,"right"),fi.forEach(t),Qa=r(Ee," nodes are tracked in each "),it=i(Ee,"CODE",{});var ui=s(it);Va=r(ui,"node"),ui.forEach(t),Ee.forEach(t),Xa=h(A),st=i(A,"LI",{});var mi=s(st);Ya=r(mi,"algorithm for insertion / search requires recursion (for search - if less go left, else go right until the end, while for insertion - if less go left, else go right. If value is null, insert or end search)"),mi.forEach(t),$a=h(A),nt=i(A,"LI",{});var pi=s(nt);er=r(pi,"Logarithmic time (~2 ln N) for insertion and search for the average case."),pi.forEach(t),tr=h(A),se=i(A,"LI",{});var fo=s(se);lr=r(fo,"Deleting a node in a binary search tree isn’t so simple"),G=i(fo,"UL",{});var $t=s(G);ne=i($t,"LI",{});var uo=s(ne);ar=r(uo,"‘tombstone’ method / lazy delete - where it’s not really deleted, and node is just updated to "),ht=i(uo,"CODE",{});var vi=s(ht);rr=r(vi,"null"),vi.forEach(t),uo.forEach(t),or=h($t),he=i($t,"LI",{});var mo=s(he);ir=r(mo,"Hibbard deletion is considered (where we swap the node to be deleted with its successor), but has flaws as it makes the tree asymmetric and unbalanced, which presents problems and we should NOT have a dynamic changes"),dt=i(mo,"UL",{});var bi=s(dt);z=i(bi,"LI",{});var el=s(z);sr=r(el,"When tree is no longer balanced and random, then operations for the worst case will take "),ct=i(el,"CODE",{});var Ei=s(ct);nr=r(Ei,"sqrt(N)"),Ei.forEach(t),hr=r(el," which is worse than the balanced binary search tree. Thus, we need a better algorithm to guarantee better and optimal performance (this is found in the red-black BST)"),el.forEach(t),bi.forEach(t),mo.forEach(t),$t.forEach(t),fo.forEach(t),A.forEach(t),Zt=h(l),de=i(l,"H3",{});var gi=s(de);dr=r(gi,"Red-black BSTs"),gi.forEach(t),Jt=h(l),f=i(l,"UL",{});var p=s(f);ft=i(p,"LI",{});var wi=s(ft);cr=r(wi,"A way to guarantee logarithmic performance for binary search trees"),wi.forEach(t),fr=h(p),W=i(p,"LI",{});var tl=s(W);ut=i(tl,"STRONG",{});var _i=s(ut);ur=r(_i,"2-3 trees"),_i.forEach(t),mr=r(tl," are 2-node or 3-node trees"),F=i(tl,"UL",{});var ll=s(F);mt=i(ll,"LI",{});var yi=s(mt);pr=r(yi,"2 node = 1 key with 2 children"),yi.forEach(t),vr=h(ll),pt=i(ll,"LI",{});var ki=s(pt);br=r(ki,"3 node = 2 keys, 3 children"),ki.forEach(t),ll.forEach(t),tl.forEach(t),Er=h(p),vt=i(p,"LI",{});var Li=s(vt);gr=r(Li,"Must be perfectly balanced and symmetric"),Li.forEach(t),wr=h(p),bt=i(p,"LI",{});var Ii=s(bt);_r=r(Ii,"If a 4-node occurs, this must be ‘promoted’ and split into 2 nodes"),Ii.forEach(t),yr=h(p),ce=i(p,"LI",{});var po=s(ce);kr=r(po,"2-3 trees has transformations to maintain this symmetric order and balance where operations are guaranteed logarithmic run time "),Et=i(po,"CODE",{});var qi=s(Et);Lr=r(qi,"c log N"),qi.forEach(t),po.forEach(t),Ir=h(p),gt=i(p,"LI",{});var Ti=s(gt);qr=r(Ti,"However, the implementation for 2-3 trees is complex, thus we consider red-black BSTs instead"),Ti.forEach(t),Tr=h(p),Z=i(p,"LI",{});var al=s(Z);wt=i(al,"STRONG",{});var Ci=s(wt);Cr=r(Ci,"Red black BST"),Ci.forEach(t),Sr=r(al,": BST that has no 2 red links connected to it, every path from root to link has the same number of black links, and red links all lean left (“internal” left leaning links act as “glue” for 3 nodes)"),q=i(al,"UL",{});var P=s(q);_t=i(P,"LI",{});var Si=s(_t);Or=r(Si,"all operations are pretty much the same implementation as a BST with the exception of insertion to achieve balance"),Si.forEach(t),xr=h(P),u=i(P,"LI",{});var v=s(u);Ar=r(v,"Utilities to help include identifying whether a node is "),yt=i(v,"CODE",{});var Oi=s(yt);Nr=r(Oi,"red"),Oi.forEach(t),Dr=r(v," link, or a "),kt=i(v,"CODE",{});var xi=s(kt);Br=r(xi,"black"),xi.forEach(t),Hr=r(v," link, or whether a "),Lt=i(v,"CODE",{});var Ai=s(Lt);Rr=r(Ai,"leftRotation"),Ai.forEach(t),Ur=r(v," or "),It=i(v,"CODE",{});var Ni=s(It);Pr=r(Ni,"rightRotation"),Ni.forEach(t),Mr=r(v," is required (these are required as red-black BSTs are required to be left leaning, "),qt=i(v,"CODE",{});var Di=s(qt);jr=r(Di,"rightRotation"),Di.forEach(t),Gr=r(v," is generally temporary state to achieve left leaning later), or to flip colours of a link (turn a "),Tt=i(v,"CODE",{});var Bi=s(Tt);zr=r(Bi,"red"),Bi.forEach(t),Wr=r(v," link to "),Ct=i(v,"CODE",{});var Hi=s(Ct);Fr=r(Hi,"black"),Hi.forEach(t),Zr=r(v," link after rotation if applicable for a temporary 4-node being split into 2-nodes)"),v.forEach(t),Jr=h(P),St=i(P,"LI",{});var Ri=s(St);Kr=r(Ri,"Recursion makes this algorithm straightforward to implement (but complex to understand) and covers several edge cases. If we had to impelment this without recursion, it would be difficult due to the number of edge cases to be considered."),Ri.forEach(t),Qr=h(P),J=i(P,"LI",{});var rl=s(J);Vr=r(rl,"Height of a red-black BST is at most less than or equal to "),Ot=i(rl,"CODE",{});var Ui=s(Ot);Xr=r(Ui,"2 log N"),Ui.forEach(t),Yr=r(rl,", and thus the operations (including deletion via Hibbard’s deletion) would take at most logarithmic running time."),rl.forEach(t),P.forEach(t),al.forEach(t),$r=h(p),xt=i(p,"LI",{});var Pi=s(xt);eo=r(Pi,"Applications include file system model in operating systems and databases, treemap / treeset utilities, stack scanning"),Pi.forEach(t),p.forEach(t),Kt=h(l),fe=i(l,"P",{});var Mi=s(fe);to=r(Mi,"Should hope to wrap up the lectures from this course and dive deep into implementing these from scratch soon."),Mi.forEach(t),Qt=h(l),ue=i(l,"H3",{});var ji=s(ue);lo=r(ji,"References"),ji.forEach(t),Vt=h(l),H=i(l,"UL",{});var ol=s(H);me=i(ol,"LI",{});var vo=s(me);K=i(vo,"A",{href:!0,rel:!0});var Gi=s(K);ao=r(Gi,"Algorithms, Part 1"),Gi.forEach(t),ro=r(vo," course on Coursera (modules 8-10)"),vo.forEach(t),oo=h(ol),Q=i(ol,"LI",{});var il=s(Q);io=r(il,"More about "),V=i(il,"A",{href:!0,rel:!0});var zi=s(V);so=r(zi,"Hibbard Deletion"),zi.forEach(t),no=r(il," - Oxford College CS171"),il.forEach(t),ol.forEach(t),this.h()},h(){sl(K,"href","https://www.coursera.org/learn/algorithms-part1"),sl(K,"rel","nofollow"),sl(V,"href","https://mathcenter.oxford.emory.edu/site/cs171/hibbardDeletion/"),sl(V,"rel","nofollow")},m(l,d){c(l,T,d),e(T,nl),e(T,ge),e(ge,hl),e(T,dl),c(l,At,d),c(l,X,d),e(X,cl),c(l,Nt,d),c(l,m,d),e(m,we),e(we,fl),e(m,ul),e(m,_e),e(_e,ml),e(m,pl),e(m,ye),e(ye,vl),e(m,bl),e(m,ke),e(ke,El),e(m,gl),e(m,Le),e(Le,wl),e(m,_l),e(m,Ie),e(Ie,yl),c(l,Dt,d),c(l,Y,d),e(Y,kl),c(l,Bt,d),c(l,$,d),e($,ee),e(ee,Ll),e(ee,L),e(L,qe),e(qe,Il),e(L,ql),e(L,Te),e(Te,Tl),e(L,Cl),e(L,Ce),e(Ce,Sl),e(L,Ol),e(L,Se),e(Se,xl),c(l,Ht,d),c(l,te,d),e(te,Al),c(l,Rt,d),c(l,E,d),e(E,Oe),e(Oe,Nl),e(E,Dl),e(E,xe),e(xe,Bl),e(E,Hl),e(E,Ae),e(Ae,Rl),e(E,Ul),e(E,N),e(N,Pl),e(N,Ne),e(Ne,Ml),e(N,jl),e(N,De),e(De,Gl),e(N,zl),e(E,Wl),e(E,Be),e(Be,Fl),c(l,Ut,d),c(l,le,d),e(le,Zl),c(l,Pt,d),c(l,g,d),e(g,M),e(M,Jl),e(M,He),e(He,Kl),e(M,Ql),e(g,Vl),e(g,j),e(j,Xl),e(j,Re),e(Re,Yl),e(j,$l),e(g,ea),e(g,Ue),e(Ue,ta),e(g,la),e(g,Pe),e(Pe,aa),e(g,ra),e(g,Me),e(Me,oa),c(l,Mt,d),c(l,ae,d),e(ae,ia),c(l,jt,d),c(l,C,d),e(C,je),e(je,sa),e(C,na),e(C,Ge),e(Ge,ha),e(C,da),e(C,ze),e(ze,ca),c(l,Gt,d),c(l,re,d),e(re,fa),c(l,zt,d),c(l,w,d),e(w,We),e(We,ua),e(w,ma),e(w,I),e(I,pa),e(I,Fe),e(Fe,va),e(I,ba),e(I,Ze),e(Ze,Ea),e(I,ga),e(I,Je),e(Je,wa),e(I,_a),e(w,ya),e(w,Ke),e(Ke,ka),e(w,La),e(w,D),e(D,Ia),e(D,Qe),e(Qe,qa),e(D,Ta),e(D,Ve),e(Ve,Ca),e(D,Sa),e(w,Oa),e(w,oe),e(oe,xa),e(oe,b),e(b,Xe),e(Xe,Aa),e(b,Na),e(b,Ye),e(Ye,Da),e(b,Ba),e(b,$e),e($e,Ha),e(b,Ra),e(b,et),e(et,Ua),e(b,Pa),e(b,tt),e(tt,Ma),e(b,ja),e(b,lt),e(lt,Ga),c(l,Wt,d),c(l,ie,d),e(ie,za),c(l,Ft,d),c(l,_,d),e(_,at),e(at,Wa),e(_,Fa),e(_,B),e(B,rt),e(rt,Za),e(B,Ja),e(B,ot),e(ot,Ka),e(B,Qa),e(B,it),e(it,Va),e(_,Xa),e(_,st),e(st,Ya),e(_,$a),e(_,nt),e(nt,er),e(_,tr),e(_,se),e(se,lr),e(se,G),e(G,ne),e(ne,ar),e(ne,ht),e(ht,rr),e(G,or),e(G,he),e(he,ir),e(he,dt),e(dt,z),e(z,sr),e(z,ct),e(ct,nr),e(z,hr),c(l,Zt,d),c(l,de,d),e(de,dr),c(l,Jt,d),c(l,f,d),e(f,ft),e(ft,cr),e(f,fr),e(f,W),e(W,ut),e(ut,ur),e(W,mr),e(W,F),e(F,mt),e(mt,pr),e(F,vr),e(F,pt),e(pt,br),e(f,Er),e(f,vt),e(vt,gr),e(f,wr),e(f,bt),e(bt,_r),e(f,yr),e(f,ce),e(ce,kr),e(ce,Et),e(Et,Lr),e(f,Ir),e(f,gt),e(gt,qr),e(f,Tr),e(f,Z),e(Z,wt),e(wt,Cr),e(Z,Sr),e(Z,q),e(q,_t),e(_t,Or),e(q,xr),e(q,u),e(u,Ar),e(u,yt),e(yt,Nr),e(u,Dr),e(u,kt),e(kt,Br),e(u,Hr),e(u,Lt),e(Lt,Rr),e(u,Ur),e(u,It),e(It,Pr),e(u,Mr),e(u,qt),e(qt,jr),e(u,Gr),e(u,Tt),e(Tt,zr),e(u,Wr),e(u,Ct),e(Ct,Fr),e(u,Zr),e(q,Jr),e(q,St),e(St,Kr),e(q,Qr),e(q,J),e(J,Vr),e(J,Ot),e(Ot,Xr),e(J,Yr),e(f,$r),e(f,xt),e(xt,eo),c(l,Kt,d),c(l,fe,d),e(fe,to),c(l,Qt,d),c(l,ue,d),e(ue,lo),c(l,Vt,d),c(l,H,d),e(H,me),e(me,K),e(K,ao),e(me,ro),e(H,oo),e(H,Q),e(Q,io),e(Q,V),e(V,so),e(Q,no)},p:bo,i:bo,o:bo,d(l){l&&t(T),l&&t(At),l&&t(X),l&&t(Nt),l&&t(m),l&&t(Dt),l&&t(Y),l&&t(Bt),l&&t($),l&&t(Ht),l&&t(te),l&&t(Rt),l&&t(E),l&&t(Ut),l&&t(le),l&&t(Pt),l&&t(g),l&&t(Mt),l&&t(ae),l&&t(jt),l&&t(C),l&&t(Gt),l&&t(re),l&&t(zt),l&&t(w),l&&t(Wt),l&&t(ie),l&&t(Ft),l&&t(_),l&&t(Zt),l&&t(de),l&&t(Jt),l&&t(f),l&&t(Kt),l&&t(fe),l&&t(Qt),l&&t(ue),l&&t(Vt),l&&t(H)}}}const Vi={title:"Weekly learning review - Algorithms: Part I - 2",date:"2024-08-11T21:10:00.000Z"};class Xi extends Fi{constructor(T){super(),Zi(this,T,null,Ki,Ji,{})}}export{Xi as default,Vi as metadata};
