<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link
			rel="stylesheet"
			href="https://fonts.googleapis.com/css?family=DM+Sans:bold,regular|DM+Serif+Display"
		/>
		<link rel="icon" href="/favicon.png" />
		<meta name="viewport" content="width=device-width" />
		
		<link href="../_app/immutable/assets/0.MJlgQV0A.css" rel="stylesheet">
		<link href="../_app/immutable/assets/4.Cg9rY0U1.css" rel="stylesheet">
		<link rel="modulepreload" href="../_app/immutable/entry/start.WtSCaRy8.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/entry.BCdJq5-W.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/runtime.Bs2-O94s.js">
		<link rel="modulepreload" href="../_app/immutable/entry/app.LkcVNmh9.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/preload-helper.BMBOYjXM.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/render.CbMYC6RU.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/disclose-version.hD3RjQbW.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/props.u9dedcIT.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/store.KntsMKcj.js">
		<link rel="modulepreload" href="../_app/immutable/nodes/0.CbRJ5syk.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/legacy.C6sgJd9a.js">
		<link rel="modulepreload" href="../_app/immutable/nodes/4.BZsEkjwR.js">
	</head>

	<body data-sveltekit-preload-data="hover">
		<div style="display: contents"><!--[--><!--[--><!----><header class="svelte-1n1kweh"><h1 class="svelte-1n1kweh">Blog - docs, notes, weird discoveries and ramblings all in one place.</h1></header><!----> <main><!----><!----><article class="svelte-med8i0"><h1>Weekly learning review - browser rendering pipeline (critical rendering path)</h1> <p>10 November, 2024</p> <div class="line-break svelte-med8i0"></div> <div class="post-content svelte-med8i0"><!----><p><em>Took 3 weeks off for a 2 week vacation - much overdue but glad to be back - travelling is physically tiring… or I’m in need of exercise.</em></p> <p>This week’s highlights was jumping into Lydia Hallie’s Web Development Quiz (which was hard, as expected) - but has so many things that I should know!
The main one was really getting into more detail about the browser rendering pipeline and how different CSS properties have an effect on which parts of the pipeline are used (for example, changing widths will require layout, paint and composite processes to rerun, while opacity only requires composite, and a change in background image assuming that width and height have not changed only requires a re-paint and composite process).</p> <h3>What is the critical rendering path / browser rendering pipeline?</h3> <ul><li>“Sequence of steps browser goes through to convert HTML, CSS, JS into pixels onto the screen” - MDN</li> <li>involves DOM, CSSOM, render tree and layout.</li> <li>it is the minimum amount of resources necessary to perform an initial page render (not any subsequent updates)
This is sometimes referred to as the browser rendering pipeline.</li></ul> <p>When the browser receives data, it will begin parsing the information. This means HTML is being parsed, which then gets translated into the DOM and CSSOM, which make up the render tree, which is then passed to the renderer to then layout, paint, and composite the page to the screen.</p> <p>There are 5 steps to the critical rendering path:</p> <ol><li><strong>HTML parsing to construct DOM tree</strong> <ul><li>HTML parsing which involves tokenization and tree construction. This creates the DOM tree.</li></ul></li> <li><strong>Processing stylesheets / CSS to construct CSSOM tree</strong> Next is processing CSS and the creating the CSSOM tree. This involves mapping styles with the nodes and identifying relationships between the CSS selectors. <ul><li>any JavaScript scripts are downloaded, parsed, compiled and interpreted into abstract syntax trees. Most of this occurs on the main thread and is happening in the background. Note that any <code>script</code> tags would need to be parsed (unless they have <code>defer</code>, <code>async</code> or <code>module</code> attributes applied) and thus blocks the HTML parser from proceeding as it could change the DOM.</li></ul></li> <li><strong>Style - Construction of render tree</strong> After the DOM and CSSOM tree has been constructed, these are combined into a single tree known as the the render tree (which only has the visible elements available - this does not include anything with <code>display: hidden</code> or visually hidden elements such as <code>head</code> and <code>script</code> elements). This can also be referred to as the style step. The render tree starts from the root of the tree, traversing into each node. Rendering steps take place (which is what we refer to as the rendering pipeline).
The rendering steps are next.</li> <li><strong>Layout</strong> <ul><li>the layout step is to compute the geometry of every node and how each node is relative to each other (every width, height, position, size of each element / node on the page / tree). Whenever reflow occurs, this means that layout has shifted and requires a recalculation. This could involve a subset of elements that end up being re-computed, or the entire document depending on how many elements need to be shifted. The box model is adhered to when laying out elements.</li></ul></li> <li><strong>Paint / Composite</strong> Once everything is laid out, we move onto the next step which is painting. Every box /element is now translated into pixels on the screen which includes text, colours, images, buttons. Generally, this step should be optimised and the browser does this efficiently. If there are lots of elements to be painted, then the screen could be broken down into several layers and the composed together. <ul><li>Compositing involves combining and merging layers together to produce the final image that appears on the screen. Some elements have been painted on separate layers for optimization and efficiency. The gains are from promoting elements to these layers which are then painted by the GPU rather than on the main thread, giving the performance boost. <ul><li>some elements have this already built in such as <code>video</code>, <code>canvas</code> tags and CSS properties such as <code>opacity</code>, <code>transform</code>, <code>will-change</code></li> <li>Take caution if we want to explicitly do this - although they may improve performance, they should not be overused (as the browser usually does this for you already under the hood)</li> <li>This step is also necessary to make sure the document is drawing elements in the right order</li></ul></li></ul></li></ol> <h3>Why is this important?</h3> <p>It’s important to understand this process as this can help us identify where performance issues lie, and how we could solve them to provide the best user experience possible. We want to make sure our pages are responsive. It is paramount that the applications we build can keep up with our users and their needs. Sometimes just changing a CSS property could make improve performance significantly (or what can be seen as a ‘jank user experience’). Knowing this allows us to figure out if there are ways to ‘skip’ certain processes as they are not hierarchical - we can sometimes update a style without needing layout or having to re-compute positions, while there may not need to be a reason to paint and only do compositing if the node hasn’t changed in pixels.</p> <p>Recall that JavaScript is single threaded, and that style, layout and some paint operations run on the same thread. Other steps will run on their own thread (such as other painting operations and compositing).</p> <p>Reflows (which are the equivalent of redoing the layout step) can become computationally expensive as they use CPU resources, which involves needing to re-calculate, re-paint and combine to update the elements on the screen. Because this runs on the main thread, performance and the responsiveness of the page can become affected.</p> <h3>References</h3> <ul><li>Lydia Hallie’s <a href="https://frontendmasters.com/courses/web-dev-quiz/" rel="nofollow">Advanced Web Development Quiz</a> on FrontEnd Masters</li> <li><a href="https://web.dev/articles/rendering-performance" rel="nofollow">Rendering performance</a> - web.dev</li> <li><a href="https://web.dev/learn/performance/understanding-the-critical-path" rel="nofollow">Understanding the critical path</a> - web.dev</li> <li><a href="https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work" rel="nofollow">Web performance - Populating the page: how browsers work</a> - MDN</li> <li><a href="https://www.chromium.org/developers/the-rendering-critical-path/" rel="nofollow">The rendering critical path</a> - Chromium</li> <li><a href="https://webperf.tips/tip/browser-rendering-pipeline/" rel="nofollow">An Introduction to the Browser Rendering Pipeline</a> - Joe Liccini</li></ul><!----></div></article><!----><!----></main> <footer class="svelte-1stbkrt"><nav class="svelte-1stbkrt"><ul><a href="/">Home</a></ul></nav> <p class="svelte-1stbkrt">Built with SvelteKit | 2023.</p></footer><!----><!----><!--]--> <!--[!--><!--]--><!--]-->
			
			<script>
				{
					__sveltekit_undike = {
						base: new URL("..", location).pathname.slice(0, -1)
					};

					const element = document.currentScript.parentElement;

					Promise.all([
						import("../_app/immutable/entry/start.WtSCaRy8.js"),
						import("../_app/immutable/entry/app.LkcVNmh9.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 4],
							data: [null,null],
							form: null,
							error: null
						});
					});
				}
			</script>
		</div>
	</body>
</html>
